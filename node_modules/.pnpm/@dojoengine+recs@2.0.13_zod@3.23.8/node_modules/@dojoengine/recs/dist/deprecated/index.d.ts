import { g as Components, E as Entity, o as Override, n as SchemaOf, W as World, S as Schema, M as Metadata, C as Component, O as OverridableComponent, T as Type } from '../types-3444e4c1.js';
import { Observable } from 'rxjs';
import { ValueOf } from '@latticexyz/utils';
import 'type-fest';

declare enum ActionState {
    Requested = "Requested",
    Executing = "Executing",
    WaitingForTxEvents = "WaitingForTxEvents",
    Complete = "Complete",
    Failed = "Failed",
    Cancelled = "Cancelled",
    TxReduced = "TxReduced"
}

type ComponentUpdate<C extends Components> = ValueOf<{
    [key in keyof C]: {
        component: C[key];
        entity: Entity;
        value: Override<SchemaOf<C[key]>>["value"];
    };
}>;
type ActionRequest<C extends Components, T, M = unknown> = {
    id: string;
    on?: Entity;
    components: C;
    requirement: (componentsWithOptimisticUpdates: C) => T | null;
    updates: (componentsWithOptimisticUpdates: C, data: T) => ComponentUpdate<C>[];
    execute: (data: T) => Promise<string> | Promise<void> | void | undefined;
    awaitConfirmation?: boolean;
    metadata?: M;
};

type ActionSystem = ReturnType<typeof createActionSystem>;
/**
 * @deprecated For now, we suggest using `overridableComponent(Component)` and `addOverride`/`removeOverride` to manage overrides yourself.
 */
declare function createActionSystem<M = unknown>(world: World, txReduced$: Observable<string>, waitForTransaction?: (tx: string) => Promise<void>): {
    add: <C extends Components, T>(actionRequest: ActionRequest<C, T, M>) => Entity;
    cancel: (actionId: string) => boolean;
    withOptimisticUpdates: <S extends Schema, M_1 extends Metadata, T_1>(component: Component<S, M_1, T_1>) => OverridableComponent<S, M_1, T_1>;
    Action: Component<{
        state: Type.String;
        on: Type.OptionalEntity;
        metadata: Type.OptionalT;
        overrides: Type.OptionalStringArray;
        txHash: Type.OptionalString;
    }, Metadata, M>;
};

export { ActionState, ActionSystem, createActionSystem };

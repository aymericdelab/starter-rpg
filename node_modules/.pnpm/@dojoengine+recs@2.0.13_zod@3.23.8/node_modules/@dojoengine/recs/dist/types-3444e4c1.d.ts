import { Subject } from 'rxjs';
import { Opaque } from 'type-fest';

/**
 * Type enum is used to specify value types in {@link ComponentSchema} to be able
 * to access type values in JavaScript in addition to TypeScript type checks.
 */
declare enum Type {
    Boolean = 0,
    Number = 1,
    OptionalNumber = 2,
    BigInt = 3,
    OptionalBigInt = 4,
    String = 5,
    OptionalString = 6,
    NumberArray = 7,
    OptionalNumberArray = 8,
    BigIntArray = 9,
    OptionalBigIntArray = 10,
    StringArray = 11,
    OptionalStringArray = 12,
    Entity = 13,
    OptionalEntity = 14,
    EntityArray = 15,
    OptionalEntityArray = 16,
    T = 17,
    OptionalT = 18,
    Schema = 19
}
/**
 * Used to specify type of {@link ComponentUpdate}.
 * - Enter: Update added a value to an entity that did not have a value before
 * - Exit: Update removed a value from an entity that had a value before
 * - Update: Update changed a value of an entity that already had a value before. Note: the value doesn't need to be different from the previous value.
 * - Noop: Update did nothing (removed a value from an entity that did not have a value)
 */
declare enum UpdateType {
    Enter = 0,
    Exit = 1,
    Update = 2,
    Noop = 3
}
/**
 * Helper constant with all optional {@link Type}s.
 */
declare const OptionalTypes: Type[];

/**
 * Entities are represented as symbols internally for memory efficiency.
 * To get the entity's string representation, use `getEntityString(entitySymbol)`
 */
type EntitySymbol = Opaque<symbol, "EntitySymbol">;
type Entity = Opaque<string, "Entity">;
/**
 * Used to define the schema of a {@link Component}.
 * Uses {@link Type} enum to be able to access the component type in JavaScript as well as have TypeScript type checks.
 */
type Schema = {
    [key: string]: Type | Schema;
};
/**
 * Used to add arbitrary metadata to components.
 */
type Metadata = {
    [key: string]: unknown;
} | undefined;
/**
 * Mapping between JavaScript {@link Type} enum and corresponding TypeScript type.
 */
type ValueType<T = unknown> = {
    [Type.Boolean]: boolean;
    [Type.Number]: number;
    [Type.BigInt]: bigint;
    [Type.String]: string;
    [Type.NumberArray]: number[];
    [Type.BigIntArray]: bigint[];
    [Type.StringArray]: string[];
    [Type.Entity]: Entity;
    [Type.EntityArray]: Entity[];
    [Type.OptionalNumber]: number | undefined;
    [Type.OptionalBigInt]: bigint | undefined;
    [Type.OptionalBigIntArray]: bigint[] | undefined;
    [Type.OptionalString]: string | undefined;
    [Type.OptionalNumberArray]: number[] | undefined;
    [Type.OptionalStringArray]: string[] | undefined;
    [Type.OptionalEntity]: Entity | undefined;
    [Type.OptionalEntityArray]: Entity[] | undefined;
    [Type.T]: T;
    [Type.OptionalT]: T | undefined;
};
/**
 * Used to infer the TypeScript type of a component value corresponding to a given {@link Schema}.
 */
type ComponentValue<S extends Schema = Schema, T = unknown> = {
    [key in keyof S]: S[key] extends Schema ? ComponentValue<S[key], T> : ValueType<T>[S[key] extends keyof ValueType<T> ? S[key] : any];
};
/**
 * Type of a component update corresponding to a given {@link Schema}.
 */
type ComponentUpdate<S extends Schema = Schema, T = unknown> = {
    entity: Entity;
    value: [ComponentValue<S, T> | undefined, ComponentValue<S, T> | undefined];
    component: Component<S, Metadata, T>;
};
/**
 * Type of component returned by {@link defineComponent}.
 */
interface Component<S extends Schema = Schema, M extends Metadata = Metadata, T = unknown> {
    id: string;
    values: {
        [key in keyof S]: Map<EntitySymbol, S[key] extends Schema ? ComponentValue<S[key], T> : ValueType<T>[S[key] extends keyof ValueType<T> ? S[key] : any]>;
    };
    schema: S;
    metadata: M;
    entities: () => IterableIterator<Entity>;
    world: World;
    update$: Subject<ComponentUpdate<S, T>> & {
        observers: any;
    };
}
/**
 * Type of indexer returned by {@link createIndexer}.
 */
type Indexer<S extends Schema, M extends Metadata = Metadata, T = unknown> = Component<S, M, T> & {
    getEntitiesWithValue: (value: ComponentValue<S, T>) => Set<Entity>;
};
type Components = {
    [key: string]: Component;
};
interface ComponentWithStream<S extends Schema, T = unknown> extends Component<S, Metadata, T> {
    stream$: Subject<{
        entity: Entity;
        value: ComponentValue<S, T> | undefined;
    }>;
}
type AnyComponentValue = ComponentValue<Schema>;
type AnyComponent = Component<Schema>;
/**
 * Type of World returned by {@link createWorld}.
 */
type World = {
    registerEntity: (options?: {
        id?: string;
        idSuffix?: string;
    }) => Entity;
    registerComponent: (component: Component) => void;
    components: Component[];
    getEntities: () => IterableIterator<Entity>;
    dispose: () => void;
    registerDisposer: (disposer: () => void) => void;
    hasEntity: (entity: Entity) => boolean;
    deleteEntity: (entity: Entity) => void;
    entitySymbols: Set<EntitySymbol>;
};
declare enum QueryFragmentType {
    Has = 0,
    HasValue = 1,
    Not = 2,
    NotValue = 3,
    ProxyRead = 4,
    ProxyExpand = 5
}
type HasQueryFragment<T extends Schema> = {
    type: QueryFragmentType.Has;
    component: Component<T>;
};
type HasValueQueryFragment<T extends Schema> = {
    type: QueryFragmentType.HasValue;
    component: Component<T>;
    value: Partial<ComponentValue<T>>;
};
type NotQueryFragment<T extends Schema> = {
    type: QueryFragmentType.Not;
    component: Component<T>;
};
type NotValueQueryFragment<T extends Schema> = {
    type: QueryFragmentType.NotValue;
    component: Component<T>;
    value: Partial<ComponentValue<T>>;
};
type ProxyReadQueryFragment = {
    type: QueryFragmentType.ProxyRead;
    component: Component<{
        value: Type.Entity;
    }>;
    depth: number;
};
type ProxyExpandQueryFragment = {
    type: QueryFragmentType.ProxyExpand;
    component: Component<{
        value: Type.Entity;
    }>;
    depth: number;
};
type QueryFragment<T extends Schema = Schema> = HasQueryFragment<T> | HasValueQueryFragment<T> | NotQueryFragment<T> | NotValueQueryFragment<T> | ProxyReadQueryFragment | ProxyExpandQueryFragment;
type EntityQueryFragment<T extends Schema = Schema> = HasQueryFragment<T> | HasValueQueryFragment<T> | NotQueryFragment<T> | NotValueQueryFragment<T>;
type SettingQueryFragment = ProxyReadQueryFragment | ProxyExpandQueryFragment;
type QueryFragments = QueryFragment<Schema>[];
type SchemaOf<C extends Component<Schema>> = C extends Component<infer S> ? S : never;
type Override<S extends Schema, T = unknown> = {
    entity: Entity;
    value: Partial<ComponentValue<S, T>> | null;
};
/**
 * Type of overridable component returned by {@link overridableComponent}.
 */
type OverridableComponent<S extends Schema = Schema, M extends Metadata = Metadata, T = unknown> = Component<S, M, T> & {
    addOverride: (overrideId: string, update: Override<S, T>) => void;
    removeOverride: (overrideId: string) => void;
};
type OptionalType = Type.OptionalNumber | Type.OptionalBigInt | Type.OptionalString | Type.OptionalEntity | Type.OptionalNumberArray | Type.OptionalBigIntArray | Type.OptionalStringArray | Type.OptionalEntityArray;
declare function isOptionalType(t: Type): t is OptionalType;
type ArrayType = Type.NumberArray | Type.OptionalNumberArray | Type.BigIntArray | Type.OptionalBigIntArray | Type.StringArray | Type.OptionalStringArray | Type.EntityArray | Type.OptionalEntityArray;
declare function isArrayType(t: Type): t is ArrayType;
type NumberType = Type.Number | Type.OptionalNumber;
declare function isNumberType(t: Type): t is NumberType;
type EntityType = Type.Entity | Type.OptionalEntity;
declare function isEntityType(t: Type): t is EntityType;
type Layer = {
    world: World;
    components: Record<string, Component<Schema>>;
};
type Layers = Record<string, Layer>;

export { AnyComponentValue as A, Component as C, Entity as E, HasQueryFragment as H, Indexer as I, Layer as L, Metadata as M, NotQueryFragment as N, OverridableComponent as O, ProxyReadQueryFragment as P, QueryFragment as Q, Schema as S, Type as T, UpdateType as U, ValueType as V, World as W, ComponentValue as a, EntitySymbol as b, ComponentUpdate as c, HasValueQueryFragment as d, NotValueQueryFragment as e, ProxyExpandQueryFragment as f, Components as g, ComponentWithStream as h, AnyComponent as i, QueryFragmentType as j, EntityQueryFragment as k, SettingQueryFragment as l, QueryFragments as m, SchemaOf as n, Override as o, OptionalType as p, isOptionalType as q, ArrayType as r, isArrayType as s, NumberType as t, isNumberType as u, EntityType as v, isEntityType as w, Layers as x, OptionalTypes as y };

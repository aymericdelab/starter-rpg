import { S as Schema, M as Metadata, W as World, C as Component, E as Entity, a as ComponentValue, I as Indexer, O as OverridableComponent, b as EntitySymbol, Q as QueryFragment, c as ComponentUpdate, U as UpdateType, H as HasQueryFragment, N as NotQueryFragment, d as HasValueQueryFragment, e as NotValueQueryFragment, T as Type, P as ProxyReadQueryFragment, f as ProxyExpandQueryFragment } from './types-3444e4c1.js';
export { i as AnyComponent, A as AnyComponentValue, r as ArrayType, h as ComponentWithStream, g as Components, k as EntityQueryFragment, v as EntityType, L as Layer, x as Layers, t as NumberType, p as OptionalType, y as OptionalTypes, o as Override, j as QueryFragmentType, m as QueryFragments, n as SchemaOf, l as SettingQueryFragment, V as ValueType, s as isArrayType, w as isEntityType, u as isNumberType, q as isOptionalType } from './types-3444e4c1.js';
import * as rxjs from 'rxjs';
import { Observable } from 'rxjs';
import { ObservableSet } from 'mobx';
import 'type-fest';

type ComponentMutationOptions = {
    /** Skip publishing this mutation to the component's update stream. Mostly used internally during initial hydration. */
    skipUpdateStream?: boolean;
};
/**
 * Components contain state indexed by entities and are one of the fundamental building blocks in ECS.
 * Besides containing the state, components expose an rxjs update$ stream, that emits an event any time the value
 * of an entity in this component is updated.
 *
 * @param world {@link World} object this component should be registered onto.
 * @param schema {@link Schema} of component values. Uses Type enum as bridge between typescript types and javascript accessible values.
 * @param options Optional: {
 *    id: descriptive id for this component (otherwise an autogenerated id is used),
 *    metadata: arbitrary metadata,
 *    indexed: if this flag is set, an indexer is applied to this component (see {@link createIndexer})
 * }
 * @returns Component object linked to the provided World
 *
 * @example
 * ```
 * const Position = defineComponent(world, { x: Type.Number, y: Type.Number }, { id: "Position" });
 * ```
 */
declare function defineComponent<S extends Schema, M extends Metadata, T = unknown>(world: World, schema: S, options?: {
    id?: string;
    metadata?: M;
    indexed?: boolean;
}): Component<S, M, T>;
/**
 * Set the value for a given entity in a given component.
 *
 * @param component {@link defineComponent Component} to be updated.
 * @param entity {@link Entity} whose value in the given component should be set.
 * @param value Value to set, schema must match the component schema.
 *
 * @example
 * ```
 * setComponent(Position, entity, { x: 1, y: 2 });
 * ```
 */
declare function setComponent<S extends Schema, T = unknown>(component: Component<S, Metadata, T>, entity: Entity, value: ComponentValue<S, T>, options?: ComponentMutationOptions): void;
/**
 * Update the value for a given entity in a given component while keeping the old value of keys not included in the update.
 *
 * @param component {@link defineComponent Component} to be updated.
 * @param entity {@link Entity} whose value in the given component should be updated.
 * @param value Partial value to be set, remaining keys will be taken from the existing component value.
 *
 * @remarks
 * This function fails silently during runtime if a partial value is set for an entity that
 * does not have a component value yet, since then a partial value will be set in the component for this entity.
 *
 * @example
 * ```
 * updateComponent(Position, entity, { x: 1 });
 * ```
 */
declare function updateComponent<S extends Schema, T = unknown>(component: Component<S, Metadata, T>, entity: Entity, value: Partial<ComponentValue<S, T>>, initialValue?: ComponentValue<S, T>, options?: ComponentMutationOptions): void;
/**
 * Remove a given entity from a given component.
 *
 * @param component {@link defineComponent Component} to be updated.
 * @param entity {@link Entity} whose value should be removed from this component.
 */
declare function removeComponent<S extends Schema, M extends Metadata, T = unknown>(component: Component<S, M, T>, entity: Entity, options?: ComponentMutationOptions): void;
/**
 * Check whether a component contains a value for a given entity.
 *
 * @param component {@link defineComponent Component} to check whether it has a value for the given entity.
 * @param entity {@link Entity} to check whether it has a value in the given component.
 * @returns true if the component contains a value for the given entity, else false.
 */
declare function hasComponent<S extends Schema, T = unknown>(component: Component<S, Metadata, T>, entity: Entity): boolean;
/**
 * Get the value of a given entity in the given component.
 * Returns undefined if no value or only a partial value is found.
 *
 * @param component {@link defineComponent Component} to get the value from for the given entity.
 * @param entity {@link Entity} to get the value for from the given component.
 * @returns Value of the given entity in the given component or undefined if no value exists.
 */
declare function getComponentValue<S extends Schema, T = unknown>(component: Component<S, Metadata, T>, entity: Entity): ComponentValue<S, T> | undefined;
/**
 * Get the value of a given entity in the given component.
 * Throws an error if no value exists for the given entity in the given component.
 *
 * @param component {@link defineComponent Component} to get the value from for the given entity.
 * @param entity {@link Entity} of the entity to get the value for from the given component.
 * @returns Value of the given entity in the given component.
 *
 * @remarks
 * Throws an error if no value exists in the component for the given entity.
 */
declare function getComponentValueStrict<S extends Schema, T = unknown>(component: Component<S, Metadata, T>, entity: Entity): ComponentValue<S, T>;
/**
 * Compare two {@link ComponentValue}s.
 * `a` can be a partial component value, in which case only the keys present in `a` are compared to the corresponding keys in `b`.
 *
 * @param a Partial {@link ComponentValue} to compare to `b`
 * @param b Component value to compare `a` to.
 * @returns True if `a` equals `b` in the keys present in a or neither `a` nor `b` are defined, else false.
 *
 * @example
 * ```
 * componentValueEquals({ x: 1, y: 2 }, { x: 1, y: 3 }) // returns false because value of y doesn't match
 * componentValueEquals({ x: 1 }, { x: 1, y: 3 }) // returns true because x is equal and y is not present in a
 * ```
 */
declare function componentValueEquals<S extends Schema, T = unknown>(a?: Partial<ComponentValue<S, T>>, b?: ComponentValue<S, T>): boolean;
/**
 * Util to create a tuple of a component and value with matching schema.
 * (Used to enforce Typescript type safety.)
 *
 * @param component {@link defineComponent Component} with {@link ComponentSchema} `S`
 * @param value {@link ComponentValue} with {@link ComponentSchema} `S`
 * @returns Tuple `[component, value]`
 */
declare function withValue<S extends Schema, T = unknown>(component: Component<S, Metadata, T>, value: ComponentValue<S, T>): [Component<S, Metadata, T>, ComponentValue<S, T>];
/**
 * Get a set of entities that have the given component value in the given component.
 *
 * @param component {@link defineComponent Component} to get entities with the given value from.
 * @param value look for entities with this {@link ComponentValue}.
 * @returns Set with {@link Entity Entities} with the given component value.
 */
declare function getEntitiesWithValue<S extends Schema>(component: Component<S> | Indexer<S>, value: Partial<ComponentValue<S>>): Set<Entity>;
/**
 * Get a set of all entities of the given component.
 *
 * @param component {@link defineComponent Component} to get all entities from
 * @returns Set of all entities in the given component.
 */
declare function getComponentEntities<S extends Schema, T = unknown>(component: Component<S, Metadata, T>): IterableIterator<Entity>;
/**
 * An overridable component is a mirror of the source component, with functions to lazily override specific entity values.
 * Lazily override means the values are not actually set to the source component, but the override is only returned if the value is read.
 *
 * - When an override for an entity is added to the component, the override is propagated via the component's `update$` stream.
 * - While an override is set for a specific entity, no updates to the source component for this entity will be propagated to the `update$` stream.
 * - When an override is removed for a specific entity and there are more overrides targeting this entity,
 * the override with the highest nonce will be propagated to the `update$` stream.
 * - When an override is removed for a specific entity and there are no more overrides targeting this entity,
 * the non-overridden underlying component value of this entity will be propagated to the `update$` stream.
 *
 * @param component {@link defineComponent Component} to use as underlying source for the overridable component
 * @returns overridable component
 */
declare function overridableComponent<S extends Schema, M extends Metadata, T = unknown>(component: Component<S, M, T>): OverridableComponent<S, M, T>;
declare function clearLocalCache(component: Component, uniqueWorldIdentifier?: string): void;
declare function createLocalCache<S extends Schema, M extends Metadata, T = unknown>(component: Component<S, M, T>, uniqueWorldIdentifier?: string): Component<S, M, T>;

/**
 * Create an indexed component from a given component.
 *
 * @remarks
 * An indexed component keeps a "reverse mapping" from {@link ComponentValue} to the Set of {@link createEntity Entities} with this value.
 * This adds a performance overhead to modifying component values and a memory overhead since in the worst case there is one
 * Set per entity (if every entity has a different component value).
 * In return the performance for querying for entities with a given component value is close to O(1) (instead of O(#entities) in a regular non-indexed component).
 * As a rule of thumb only components that are added to many entities and are queried with {@link HasValue} a lot should be indexed (eg. the Position component).
 *
 * @dev This could be made more (memory) efficient by using a hash of the component value as key, but would require handling hash collisions.
 *
 * @param component {@link defineComponent Component} to index.
 * @returns Indexed version of the component.
 */
declare function createIndexer<S extends Schema, M extends Metadata, T = unknown>(component: Component<S, M, T>): Indexer<S, M, T>;

/**
 * Register a new entity in the given {@link World} and initialize it with the given {@link ComponentValue}s.
 *
 * @param world World object this entity should be registered in.
 * @param components Array of [{@link defineComponent Component}, {@link ComponentValue}] tuples to be added to this entity.
 * (Use {@link withValue} to generate these tuples with type safety.)
 * @param options Optional: {
 *   id: {@link Entity} for this entity. Use this for entities that were created outside of recs.
 *   idSuffix: string to be appended to the auto-generated id. Use this for improved readability. Do not use this if the `id` option is provided.
 * }
 * @returns index of this entity in the {@link World}. This {@link Entity} is used to refer to this entity in other recs methods (eg {@link setComponent}).
 * (This is to avoid having to store strings in every component.)
 */
declare function createEntity(world: World, components?: [Component, ComponentValue][], options?: {
    id?: string;
} | {
    idSuffix?: string;
}): Entity;
declare function getEntitySymbol(entityString: string): EntitySymbol;
/**
 * Get the underlying entity string of an entity symbol.
 */
declare function getEntityString(entity: EntitySymbol): Entity;

/**
 * Create a system that is called on every update of the given observable.
 *
 * @remarks
 * Advantage of using this function over directly subscribing to the RxJS observable is that the system is registered in the `world` and
 * disposed when the `world` is disposed (eg. during a hot reload in development).
 *
 * @param world {@link World} object this system should be registered in.
 * @param observable$ Observable to react to.
 * @param system System function to run on updates of the `observable$`. System function gets passed the update events from the `observable$`.
 */
declare function defineRxSystem<T>(world: World, observable$: Observable<T>, system: (event: T) => void): void;
/**
 * Create a system that is called on every event of the given {@link defineUpdateQuery update query}.
 *
 * @param world {@link World} object this system should be registered in.
 * @param query Update query to react to.
 * @param system System function to run when the result of the given update query changes.
 * @param options Optional: {
 * runOnInit: if true, run this system for all entities matching the query when the system is created.
 * Else only run on updates after the system is created. Default true.
 * }
 */
declare function defineUpdateSystem(world: World, query: QueryFragment[], system: (update: ComponentUpdate) => void, options?: {
    runOnInit?: boolean;
}): void;
/**
 * Create a system that is called on every event of the given {@link defineEnterQuery enter query}.
 *
 * @param world {@link World} object this system should be registered in.
 * @param query Enter query to react to.
 * @param system System function to run when the result of the given enter query changes.
 * @param options Optional: {
 * runOnInit: if true, run this system for all entities matching the query when the system is created.
 * Else only run on updates after the system is created. Default true.
 * }
 */
declare function defineEnterSystem(world: World, query: QueryFragment[], system: (update: ComponentUpdate) => void, options?: {
    runOnInit?: boolean;
}): void;
/**
 * Create a system that is called on every event of the given {@link defineExitQuery exit query}.
 *
 * @param world {@link World} object this system should be registered in.
 * @param query Exit query to react to.
 * @param system System function to run when the result of the given exit query changes.
 * @param options Optional: {
 * runOnInit: if true, run this system for all entities matching the query when the system is created.
 * Else only run on updates after the system is created. Default true.
 * }
 */
declare function defineExitSystem(world: World, query: QueryFragment[], system: (update: ComponentUpdate) => void, options?: {
    runOnInit?: boolean;
}): void;
/**
 * Create a system that is called on every event of the given {@link defineQuery query}.
 *
 * @param world {@link World} object this system should be registered in.
 * @param query Query to react to.
 * @param system System function to run when the result of the given query changes.
 * @param options Optional: {
 * runOnInit: if true, run this system for all entities matching the query when the system is created.
 * Else only run on updates after the system is created. Default true.
 * }
 */
declare function defineSystem(world: World, query: QueryFragment[], system: (update: ComponentUpdate & {
    type: UpdateType;
}) => void, options?: {
    runOnInit?: boolean;
}): void;
/**
 * Create a system that is called every time the given component is updated.
 *
 * @param world {@link World} object this system should be registered in.
 * @param component Component to whose updates to react.
 * @param system System function to run when the given component is updated.
 * @param options Optional: {
 * runOnInit: if true, run this system for all entities in the component when the system is created.
 * Else only run on updates after the system is created. Default true.
 * }
 */
declare function defineComponentSystem<S extends Schema>(world: World, component: Component<S>, system: (update: ComponentUpdate<S>) => void, options?: {
    runOnInit?: boolean;
}): void;
/**
 * Create a system to synchronize updates to one component with another component.
 *
 * @param world {@link World} object this system should be registered in.
 * @param query Result of `component` is added to all entites matching this query.
 * @param component Function returning the component to be added to all entities matching the given query.
 * @param value Function returning the component value to be added to all entities matching the given query.
 */
declare function defineSyncSystem<T extends Schema>(world: World, query: QueryFragment[], component: (entity: Entity) => Component<T>, value: (entity: Entity) => ComponentValue<T>, options?: {
    update?: boolean;
    runOnInit?: boolean;
}): void;

/**
 * Create a new World.
 *
 * @remarks
 * A World is the central object of an ECS application, where all {@link defineComponent Components},
 * {@link registerEntity Entities} and {@link defineSystem Systems} are registerd.
 *
 * @returns A new World
 */
declare function createWorld(): {
    registerEntity: ({ id, idSuffix }?: {
        id?: string | undefined;
        idSuffix?: string | undefined;
    }) => Entity;
    components: Component<Schema, Metadata, unknown>[];
    registerComponent: (component: Component) => void;
    dispose: (namespace?: string) => void;
    registerDisposer: (disposer: () => void, namespace?: string) => void;
    hasEntity: (entity: Entity) => boolean;
    getEntities: () => IterableIterator<Entity>;
    entitySymbols: Set<EntitySymbol>;
    deleteEntity: (entity: Entity) => void;
};
/**
 * Create a new namespace from an existing World.
 * The `dispose` method of a namespaced World only calls disposers registered on this namespace.
 *
 * @param world World to create a new namespace for.
 * @param namespace String descriptor of the new namespace.
 * @returns World with a new namespace.
 */
declare function namespaceWorld(world: ReturnType<typeof createWorld>, namespace: string): {
    registerDisposer: (disposer: () => void) => void;
    dispose: () => void;
    registerEntity: ({ id, idSuffix }?: {
        id?: string | undefined;
        idSuffix?: string | undefined;
    }) => Entity;
    components: Component<Schema, Metadata, unknown>[];
    registerComponent: (component: Component<Schema, Metadata, unknown>) => void;
    hasEntity: (entity: Entity) => boolean;
    getEntities: () => IterableIterator<Entity>;
    entitySymbols: Set<EntitySymbol>;
    deleteEntity: (entity: Entity) => void;
};
/**
 * Get all components that have a value for the given entity.
 *
 * @dev Design decision: don't store a list of components for each entity but compute it dynamically when needed
 * because there are less components than entities and maintaining a list of components per entity is a large overhead.
 *
 * @param world World object the given entity is registered on.
 * @param entity {@link Entity} to get the list of components for.
 * @returns Array of components that have a value for the given entity.
 */
declare function getEntityComponents(world: World, entity: Entity): Component[];

/**
 * Create a {@link HasQueryFragment}.
 *
 * @remarks
 * The {@link HasQueryFragment} filters for entities that have the given component,
 * independent from the component value.
 *
 * @example
 * Query for all entities with a `Position`.
 * ```
 * runQuery([Has(Position)]);
 * ```
 *
 * @param component Component this query fragment refers to.
 * @returns query fragment to be used in {@link runQuery} or {@link defineQuery}.
 */
declare function Has<T extends Schema>(component: Component<T>): HasQueryFragment<T>;
/**
 * Create a {@link NotQueryFragment}.
 *
 * @remarks
 * The {@link NotQueryFragment} filters for entities that don't have the given component,
 * independent from the component value.
 *
 * @example
 * Query for all entities with a `Position` that are not `Movable`.
 * ```
 * runQuery([Has(Position), Not(Movable)]);
 * ```
 *
 * @param component Component this query fragment refers to.
 * @returns query fragment to be used in {@link runQuery} or {@link defineQuery}.
 */
declare function Not<T extends Schema>(component: Component<T>): NotQueryFragment<T>;
/**
 * Create a {@link HasValueQueryFragment}.
 *
 * @remarks
 * The {@link HasValueQueryFragment} filters for entities that have the given component
 * with the given component value.
 *
 * @example
 * Query for all entities at Position (0,0).
 * ```
 * runQuery([HasValue(Position, { x: 0, y: 0 })]);
 * ```
 *
 * @param component Component this query fragment refers to.
 * @param value Only include entities with this (partial) component value from the result.
 * @returns query fragment to be used in {@link runQuery} or {@link defineQuery}.
 */
declare function HasValue<T extends Schema>(component: Component<T>, value: Partial<ComponentValue<T>>): HasValueQueryFragment<T>;
/**
 * Create a {@link NotValueQueryFragment}.
 *
 * @remarks
 * The {@link NotValueQueryFragment} filters for entities that don't have the given component
 * with the given component value.
 *
 * @example
 * Query for all entities that have a `Position`, except for those at `Position` (0,0).
 * ```
 * runQuery([Has(Position), NotValue(Position, { x: 0, y: 0 })]);
 * ```
 *
 * @param component Component this query fragment refers to.
 * @param value Exclude entities with this (partial) component value from the result.
 * @returns query fragment to be used in {@link runQuery} or {@link defineQuery}.
 */
declare function NotValue<T extends Schema>(component: Component<T>, value: Partial<ComponentValue<T>>): NotValueQueryFragment<T>;
/**
 * Create a {@link ProxyReadQueryFragment}.
 *
 * @remarks
 * The {@link ProxyReadQueryFragment} activates the "proxy read mode" for the rest of the query.
 * This means that for all remaining fragments in the query not only the entities themselves are checked, but also
 * their "ancestors" up to the given `depth` on the relationship chain defined by the given `component`.
 *
 * @example
 * Query for all entities that have a `Position` and are (directly or indirectly) owned by an entity with `Name` "Alice".
 * ```
 * runQuery([Has(Position), ProxyRead(OwnedByEntity, Number.MAX_SAFE_INTEGER), HasValue(Name, { name: "Alice" })]);
 * ```
 *
 * @param component Component this query fragment refers to.
 * @param depth Max depth in the relationship chain to traverse.
 * @returns query fragment to be used in {@link runQuery} or {@link defineQuery}.
 */
declare function ProxyRead(component: Component<{
    value: Type.Entity;
}>, depth: number): ProxyReadQueryFragment;
/**
 * Create a {@link ProxyExpandQueryFragment}.
 *
 * @remarks
 * The {@link ProxyExpandQueryFragment} activates the "proxy expand mode" for the rest of the query.
 * This means that for all remaining fragments in the query not only the matching entities themselves are included in the intermediate set,
 * but also all their "children" down to the given `depth` on the relationship chain defined by the given `component`.
 *
 * @example
 * Query for all entities (directly or indirectly) owned by an entity with `Name` "Alice".
 * ```
 * runQuery([ProxyExpand(OwnedByEntity, Number.MAX_SAFE_INTEGER), HasValue(Name, { name: "Alice" })]);
 * ```
 *
 * @param component Component to apply this query fragment to.
 * @param depth Max depth in the relationship chain to traverse.
 * @returns query fragment to be used in {@link runQuery} or {@link defineQuery}.
 */
declare function ProxyExpand(component: Component<{
    value: Type.Entity;
}>, depth: number): ProxyExpandQueryFragment;
/**
 * Recursively compute all direct and indirect child entities up to the specified depth
 * down the relationship chain defined by the given component.
 *
 * @param entity Entity to get all child entities for up to the specified depth
 * @param component Component to use for the relationship chain.
 * @param depth Depth up to which the recursion should be applied.
 * @returns Set of entities that are child entities of the given entity via the given component.
 */
declare function getChildEntities(entity: Entity, component: Component<{
    value: Type.Entity;
}>, depth: number): Set<Entity>;
/**
 * Execute a list of query fragments to receive a Set of matching entities.
 *
 * @remarks
 * The query fragments are executed from left to right and are concatenated with a logical `AND`.
 * For performance reasons, the most restrictive query fragment should be first in the list of query fragments,
 * in order to reduce the number of entities the next query fragment needs to be checked for.
 * If no proxy fragments are used, every entity in the resulting set passes every query fragment.
 * If setting fragments are used, the order of the query fragments influences the result, since settings only apply to
 * fragments after the setting fragment.
 *
 * @param fragments Query fragments to execute.
 * @param initialSet Optional: provide a Set of entities to execute the query on. If none is given, all existing entities are used for the query.
 * @returns Set of entities matching the query fragments.
 */
declare function runQuery(fragments: QueryFragment[], initialSet?: Set<Entity>): Set<Entity>;
/**
 * Create a query object including an update$ stream and a Set of entities currently matching the query.
 *
 * @remarks
 * `update$` stream needs to be subscribed to in order for the logic inside the stream to be executed and therefore
 * in order for the `matching` set to be updated.
 *
 * `defineQuery` should be strongly preferred over `runQuery` if the query is used for systems or other
 * use cases that repeatedly require the query result or updates to the query result. `defineQuery` does not
 * reevaluate the entire query if an accessed component changes, but only performs the minimal set of checks
 * on the updated entity to evaluate wether the entity still matches the query, resulting in significant performance
 * advantages over `runQuery`.
 *
 * The query fragments are executed from left to right and are concatenated with a logical `AND`.
 * For performance reasons, the most restrictive query fragment should be first in the list of query fragments,
 * in order to reduce the number of entities the next query fragment needs to be checked for.
 * If no proxy fragments are used, every entity in the resulting set passes every query fragment.
 * If setting fragments are used, the order of the query fragments influences the result, since settings only apply to
 * fragments after the setting fragment.
 *
 * @param fragments Query fragments to execute.
 * @param options Optional: {
 *   runOnInit: if true, the query is executed once with `runQuery` to build an iniital Set of matching entities. If false only updates after the query was created are considered.
 *   initialSet: if given, this set is passed to `runOnInit` when building the initial Set of matching entities.
 * }
 * @returns Query object: {
 *  update$: RxJS stream of updates to the query result. The update contains the component update that caused the query update, as well as the {@link UpdateType update type}.
 *  matching: Mobx observable set of entities currently matching the query.
 * }.
 */
declare function defineQuery(fragments: QueryFragment[], options?: {
    runOnInit?: boolean;
    initialSet?: Set<Entity>;
}): {
    update$: Observable<ComponentUpdate & {
        type: UpdateType;
    }>;
    matching: ObservableSet<Entity>;
};
/**
 * Define a query object that only passes update events of type {@link UpdateType}.Update to the `update$` stream.
 * See {@link defineQuery} for details.
 *
 * @param fragments Query fragments
 * @returns Stream of component updates of entities that had already matched the query
 */
declare function defineUpdateQuery(fragments: QueryFragment[], options?: {
    runOnInit?: boolean;
}): Observable<ComponentUpdate & {
    type: UpdateType;
}>;
/**
 * Define a query object that only passes update events of type {@link UpdateType}.Enter to the `update$` stream.
 * See {@link defineQuery} for details.
 *
 * @param fragments Query fragments
 * @returns Stream of component updates of entities matching the query for the first time
 */
declare function defineEnterQuery(fragments: QueryFragment[], options?: {
    runOnInit?: boolean;
}): Observable<ComponentUpdate>;
/**
 * Define a query object that only passes update events of type {@link UpdateType}.Exit to the `update$` stream.
 * See {@link defineQuery} for details.
 *
 * @param fragments Query fragments
 * @returns Stream of component updates of entities not matching the query anymore for the first time
 */
declare function defineExitQuery(fragments: QueryFragment[], options?: {
    runOnInit?: boolean;
}): Observable<ComponentUpdate>;

/**
 * Type guard to infer the TypeScript type of a given component update
 *
 * @param update Component update to infer the type of.
 * @param component {@link defineComponent Component} to check whether the given update corresponds to it.
 * @returns True (+ infered type for `update`) if `update` belongs to `component`. Else false.
 */
declare function isComponentUpdate<S extends Schema>(update: ComponentUpdate, component: Component<S>): update is ComponentUpdate<S>;
/**
 * Helper function to create a component update for the current component value of a given entity.
 *
 * @param entity Entity to create the component update for.
 * @param component Component to create the component update for.
 * @returns Component update corresponding to the given entity, the given component and the entity's current component value.
 */
declare function toUpdate<S extends Schema>(entity: Entity, component: Component<S>): ComponentUpdate<S> & {
    type: UpdateType;
};
/**
 * Helper function to turn a stream of {@link Entity Entities} into a stream of component updates of the given component.
 * @param component Component to create update stream for.
 * @returns Unary function to be used with RxJS that turns stream of {@link Entity Entities} into stream of component updates.
 */
declare function toUpdateStream<S extends Schema>(component: Component<S>): rxjs.UnaryFunction<rxjs.Observable<Entity>, rxjs.Observable<ComponentUpdate<S> & {
    type: UpdateType;
}>>;
/**
 * Helper function to check whether a given component is indexed.
 * @param c
 * @returns
 */
declare function isIndexer<S extends Schema>(c: Component<S> | Indexer<S>): c is Indexer<S>;
/**
 * Helper function to check whether a given component value is partial or full.
 * @param component
 * @param value
 * @returns
 */
declare function isFullComponentValue<S extends Schema>(component: Component<S>, value: Partial<ComponentValue<S>>): value is ComponentValue<S>;

export { Component, ComponentMutationOptions, ComponentUpdate, ComponentValue, Entity, EntitySymbol, Has, HasQueryFragment, HasValue, HasValueQueryFragment, Indexer, Metadata, Not, NotQueryFragment, NotValue, NotValueQueryFragment, OverridableComponent, ProxyExpand, ProxyExpandQueryFragment, ProxyRead, ProxyReadQueryFragment, QueryFragment, Schema, Type, UpdateType, World, clearLocalCache, componentValueEquals, createEntity, createIndexer, createLocalCache, createWorld, defineComponent, defineComponentSystem, defineEnterQuery, defineEnterSystem, defineExitQuery, defineExitSystem, defineQuery, defineRxSystem, defineSyncSystem, defineSystem, defineUpdateQuery, defineUpdateSystem, getChildEntities, getComponentEntities, getComponentValue, getComponentValueStrict, getEntitiesWithValue, getEntityComponents, getEntityString, getEntitySymbol, hasComponent, isComponentUpdate, isFullComponentValue, isIndexer, namespaceWorld, overridableComponent, removeComponent, runQuery, setComponent, toUpdate, toUpdateStream, updateComponent, withValue };

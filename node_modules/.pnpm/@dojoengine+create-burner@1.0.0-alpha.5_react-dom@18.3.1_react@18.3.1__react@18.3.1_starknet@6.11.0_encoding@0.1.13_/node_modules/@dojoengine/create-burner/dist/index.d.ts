import { Connector } from '@starknet-react/core';
import { AccountInterface, Account, RpcProvider } from 'starknet';
import { IStarknetWindowObject } from 'get-starknet-core';
import * as react from 'react';
import { ReactNode } from 'react';

/** Burner connector options. */
interface BurnerConnectorOptions {
    /** The connector id. */
    id: string;
    /** Connector human readable name. */
    name?: string;
    /** Connector icons. */
    icon?: ConnectorIcons;
}
/** Non exported types from @starknet-react/core*/
/** Connector icons, as base64 encoded svg. */
type ConnectorIcons = {
    /** Dark-mode icon. */
    dark?: string;
    /** Light-mode icon. */
    light?: string;
};
/** Connector data. */
type ConnectorData = {
    /** Connector account. */
    account?: string;
    /** Connector network. */
    chainId?: bigint;
};
/**
 *
 * @class BurnerConnector
 *
 * @description Extends the Connector class and implements the AccountInterface.
 *             This class is used to connect to the Burner Wallet.
 *
 *
 */
declare class BurnerConnector extends Connector {
    private _options;
    private _account;
    constructor(options: BurnerConnectorOptions, account: AccountInterface | Account);
    available(): boolean;
    ready(): Promise<boolean>;
    connect(): Promise<ConnectorData>;
    disconnect(): Promise<void>;
    account(): Promise<AccountInterface>;
    chainId(): Promise<bigint>;
    get id(): string;
    get name(): string;
    get icon(): ConnectorIcons;
}

declare class DojoBurnerStarknetWindowObject implements IStarknetWindowObject {
    id: string;
    name: string;
    icon: string;
    account?: AccountInterface;
    provider?: RpcProvider;
    selectedAddress?: string;
    chainId?: string;
    isConnected: boolean;
    version: string;
    burnerManager: BurnerManager;
    constructor(burnerManager: BurnerManager);
    request(call: any): Promise<void>;
    enable({ starknetVersion }?: {
        starknetVersion?: string | undefined;
    }): Promise<string[]>;
    isPreauthorized(): Promise<boolean>;
    on: (event: any, handleEvent: any) => void;
    off: (event: any, handleEvent: any) => void;
    /** @returns {string} the connector id */
    static getId(): string;
    /** @returns {string} the connector name */
    static getName(): string;
}

declare class DojoPredeployedStarknetWindowObject implements IStarknetWindowObject {
    id: string;
    name: string;
    icon: string;
    account?: AccountInterface;
    provider?: RpcProvider;
    selectedAddress?: string;
    chainId?: string;
    isConnected: boolean;
    version: string;
    predeployedManager: PredeployedManager;
    constructor(predeployedManager: PredeployedManager);
    request(call: any): Promise<void>;
    enable({ starknetVersion }?: {
        starknetVersion?: string | undefined;
    }): Promise<string[]>;
    isPreauthorized(): Promise<boolean>;
    on: (event: any, handleEvent: any) => void;
    off: (event: any, handleEvent: any) => void;
    /** @returns {string} the connector id */
    static getId(): string;
    /** @returns {string} the connector name */
    static getName(): string;
}

declare const katanaIcon = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzYgMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0xOC4yNzk4IDEzLjU4NzNDMTkuNjE5OCAxMy41ODczIDIwLjcwNjEgMTIuNTAwOCAyMC43MDYxIDExLjE2MDVDMjAuNzA2MSA5LjgyMDE3IDE5LjYxOTggOC43MzM2NCAxOC4yNzk4IDguNzMzNjRDMTYuOTM5OCA4LjczMzY0IDE1Ljg1MzUgOS44MjAxNyAxNS44NTM1IDExLjE2MDVDMTUuODUzNSAxMi41MDA4IDE2LjkzOTggMTMuNTg3MyAxOC4yNzk4IDEzLjU4NzNaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNS40MTAxNiAyLjc5NDhIMzEuMTUzOVYzLjg4NTEyQzMxLjE1MzkgNC4wODA0NiAzMS4wNzE4IDQuMjY0MjMgMzAuOTMxMiA0LjM5MzEyTDI4LjYyNiA2LjQ2NDRDMjguMzI1MSA2LjgwMDQxIDI3LjkxMSA2Ljk5MTk0IDI3LjQ4MTIgNi45OTE5NEgyNS42NTI3QzI1LjY1MjcgNi45OTE5NCAyNS42NDg4IDguNTA3NTUgMjUuNjQ4OCA5LjM5MjY1QzI1LjY0ODggMTAuMjc3NiAyNS4yODY1IDExLjIzMzIgMjUuMjg2NSAxMS4yMzMyTDI1LjUzMzQgMTEuNDgwMkMyNS43OTc5IDExLjExNyAyNi45NjY4IDkuNjc2NjQgMjcuNzQzIDkuNjc2NjRMMzAuNjc3MiA5LjY2MTA0VjEzLjQwNDhMMjUuNjQ4OCAxMy40NjM1VjIwLjc5NDhMMjQuNzY5NyAxOS45MTk0QzIzLjc2NzggMTguOTIzMyAyMi43NjQyIDE3LjkyODkgMjEuNzY1MiAxNi45Mjk5VjkuOTE1MDlDMjEuNzY1MiA4Ljg3MDU2IDIxLjk5NjkgOC4wMjA4MiAyMi4yMTAxIDcuMDg3NTlMMjIuMjEwNSA3LjA4NTY4TDIyLjIxMTkgNy4wNzk3NEwyMi4yMTM0IDcuMDczOUMyMi4yMTU0IDcuMDY2NjggMjIuMjE3MSA3LjA2MDMxIDIyLjIxNjcgNy4wNTM0MUMyMi4yMTY0IDcuMDQ3NzggMjIuMjE0NyA3LjA0MTgzIDIyLjIxMDUgNy4wMzQ5M0MyMi4xODQgNi45OTUwMiAyMi4wNzQ3IDYuOTU1MiAyMS45NzA2IDYuOTM1MjRDMjEuODkxIDYuOTIwMDYgMjEuODE0NyA2LjkxNjQ1IDIxLjc4MDggNi45MzMzM0MyMS4yMjMxIDcuMjA1MiAyMC42MzA4IDcuMzA2NjcgMjAuMDE2NiA3LjMxNzEyQzE4Ljg2MDcgNy4zMzY2MyAxNy43MDIgNy4zMzY0NSAxNi41NDYgNy4zMTcxMkMxNS45MzIzIDcuMzA2NjQgMTUuMzQwNCA3LjIwNDk2IDE0Ljc4MzIgNi45MzMzM0MxNC43MDUxIDYuODk0MjYgMTQuNDAwMyA2Ljk2NDU1IDE0LjM1MzUgNy4wMzQ5M0MxNC4zNDE3IDcuMDU0NDcgMTQuMzQ5NSA3LjA2NjE1IDE0LjM1MzUgNy4wODU2OEwxNC4zNTM5IDcuMDg3NTlDMTQuNTY3IDguMDIwNDIgMTQuNzk4OCA4Ljg3OTY5IDE0Ljc5ODggOS45MTUwOVYxNi45Mjk5QzEzLjUwNzQgMTguMjIxMyAxMi4yMDkzIDE5LjUwNiAxMC45MTUyIDIwLjc5NDhWMTMuNDYzNUw1Ljg4Njg0IDEzLjQwNDhWOS42NjEwNEw4LjgyMTAzIDkuNjc2NjRDOS41OTcyMSA5LjY3NjY0IDEwLjc2NjEgMTEuMTE3IDExLjAzMDYgMTEuNDgwMkwxMS4yNzc1IDExLjIzMzJDMTEuMjc3NSAxMS4yMzMyIDEwLjkxNTIgMTAuMjc3NiAxMC45MTUyIDkuMzkyNjVDMTAuOTE1MiA4LjUwNzU1IDEwLjkxMTMgNi45OTE5NCAxMC45MTEzIDYuOTkxOTRIOS4wODI3OEM4LjY1MzAzIDYuOTkxOTQgOC4yMzg4OCA2LjgwMDQxIDcuOTM4MDYgNi40NjQ0TDUuNjMyODQgNC4zOTMxMkM1LjQ5MjIyIDQuMjY0MjMgNS40MTAxNiA0LjA4MDQ2IDUuNDEwMTYgMy44ODUxMlYyLjc5NDhaIiBmaWxsPSIjRkYyRjQyIi8+Cjwvc3ZnPgo=";

type BurnerStorage = {
    [address: string]: BurnerRecord;
};
type BurnerRecord = {
    chainId: string;
    privateKey: string;
    publicKey: string;
    deployTx: string;
    masterAccount: string;
    active: boolean;
    accountIndex?: number;
    metadata?: any;
};
type Burner = {
    address: string;
    active: boolean;
    masterAccount?: string;
    accountIndex?: number;
};
interface BurnerManagerOptions {
    masterAccount: Account;
    accountClassHash: string;
    feeTokenAddress: string;
    rpcProvider: RpcProvider;
}
interface BurnerAccount {
    create: (options?: BurnerCreateOptions) => void;
    list: () => Burner[];
    get: (address: string) => AccountInterface;
    remove: (address: string) => void;
    account: Account;
    select: (address: string) => void;
    deselect: () => void;
    isDeploying: boolean;
    clear: () => void;
    count: number;
    copyToClipboard: () => Promise<void>;
    applyFromClipboard: () => Promise<void>;
    getActiveAccount?: () => Account | null;
    generateAddressFromSeed?: (options?: BurnerCreateOptions) => string;
    checkIsDeployed: (address: string, deployTx?: string) => Promise<boolean>;
}
interface BurnerCreateOptions {
    secret?: string;
    index?: number;
    metadata?: any;
    prefundedAmount?: string;
    maxFee?: number;
}
interface BurnerKeys {
    privateKey: string;
    publicKey: string;
    address: string;
}
type Predeployed = Burner & {
    name?: string;
};
type PredeployedStorage = {
    [address: string]: PredeployedAccount;
};
interface PredeployedManagerOptions {
    rpcProvider: RpcProvider;
    predeployedAccounts: PredeployedAccount[];
}
type PredeployedAccount = {
    name?: string;
    address: string;
    privateKey: string;
    active: boolean;
};

declare const BurnerContext: react.Context<BurnerManagerOptions | null>;
/**
 * Props for the BurnerProvider component {@link BurnerProvider}
 */
interface BurnerProviderProps {
    children: ReactNode;
    initOptions: BurnerManagerOptions;
}
/**
 * BurnerProvider
 *
 * @description This wraps the entire application in a context provider to allow for access to keep
 *            the burner manager options available to all components. Takes {@link BurnerProviderProps}.
 *
 * ```tsx
 * import { BurnerProvider } from '@dojoengine/create-burner';
 *
 * const initOptions = { ... };
 *
 * const App = () => {
 *    return (
 *       <BurnerProvider initOptions={initOptions}>
 *         <MyApp />
 *      </BurnerProvider>
 * )};
 * ```
 *
 * @param children
 * @param initOptions
 */
declare const BurnerProvider: ({ children, initOptions, }: BurnerProviderProps) => JSX.Element;

/**
 * A React hook to manage Burner accounts.
 * This hook exposes methods and properties to manage Burner accounts.
 * You need to use this within a {@link BurnerProvider} context.
 *
 * @example
 * ```tsx
 * import { useBurner } from "@dojoengine/create-burner";
 *
 * const MyComponent = () => {
 *   const { list, select, create } = useBurner();
 * const burners = list();
 *
 *   return (
 *     <div>
 *       <button onClick={() => create()}>Create Burner</button>
 *     {burners.map((burner) => (
 *       <button key={burner.address} onClick={() => select(burner.address)}>
 *         Select Burner
 *       </button>
 *    ))}
 *  </div>
 *  );
 * };
 * ```
 *
 * @returns An object with utility methods and properties.
 */
declare const useBurner: () => {
    get: (address: string) => Account;
    list: () => Burner[];
    select: (address: string) => void;
    create: (options?: BurnerCreateOptions) => Promise<Account>;
    listConnectors: () => BurnerConnector[];
    clear: () => void;
    account: Account | null;
    isDeploying: boolean;
    count: number;
    copyToClipboard: () => Promise<void>;
    applyFromClipboard: () => Promise<void>;
    generateAddressFromSeed: (options?: BurnerCreateOptions) => string;
};

/**
 * A class to manage Burner accounts.
 * This class exposes methods and properties to manage Burner accounts.
 * This class uses LocalStorage to store the Burner accounts.
 * You can use this class to build your own Burner Wallet in any js framework.
 *
 * @example
 *
 * ```ts
 * export const createBurner = async () => {
 *     const rpcProvider = new RpcProvider({
 *          nodeUrl: import.meta.env.VITE_PUBLIC_NODE_URL!,
 *    });
 *
 *  const masterAccount = new Account(
 *      rpcProvider,
 *      import.meta.env.VITE_PUBLIC_MASTER_ADDRESS!,
 *      import.meta.env.VITE_PUBLIC_MASTER_PRIVATE_KEY!,
 *      "1"
 *   );
 *
 *   const burnerManager = new BurnerManager({
 *      masterAccount,
 *      accountClassHash: import.meta.env.VITE_PUBLIC_ACCOUNT_CLASS_HASH!,
 *      rpcProvider,
 *   });
 *
 *   try {
 *           await burnerManager.init();
 *           if (burnerManager.list().length === 0) {
 *                 await burnerManager.create();
 *           }
 *       } catch (e) {
 *           console.log(e);
 *       }
 *   }
 *
 *  return {
 *      account: burnerManager.account as Account,
 *      burnerManager,
 *   };
 * };
 *
 *
 */
declare class BurnerManager {
    masterAccount: Account;
    accountClassHash: string;
    feeTokenAddress: string;
    provider: RpcProvider;
    chainId: string;
    account: Account | null;
    isDeploying: boolean;
    isInitialized: boolean;
    private setIsDeploying?;
    private afterDeploying?;
    constructor({ masterAccount, accountClassHash, feeTokenAddress, rpcProvider, }: BurnerManagerOptions);
    setIsDeployingCallback(callback: (isDeploying: boolean) => void): void;
    setAfterDeployingCallback(callback: ({ account, deployTx, }: {
        account: Account;
        deployTx: string;
    }) => Promise<void>): void;
    private updateIsDeploying;
    private getBurnerKey;
    private getBurnerStorage;
    private setActiveBurnerAccount;
    isBurnerDeployed(address: string, deployTx?: string): Promise<boolean>;
    init(keepNonDeployed?: boolean): Promise<void>;
    list(): Burner[];
    select(address: string): void;
    deselect(): void;
    get(address: string): Account;
    delete(address: string): void;
    clear(): void;
    getActiveAccount(): Account | null;
    generateKeysAndAddress(options?: BurnerCreateOptions): BurnerKeys;
    create(options?: BurnerCreateOptions): Promise<Account>;
    copyBurnersToClipboard(): Promise<void>;
    setBurnersFromClipboard(): Promise<void>;
}

/**
 * A React hook that takes the Burner Manager object avoiding the React Context.
 * Useful for building apps without React Context.
 *
 * @returns An object with utility methods and properties.
 */
declare const useBurnerManager: ({ burnerManager, }: {
    burnerManager: BurnerManager;
}) => {
    isError: boolean;
    get: (address: string) => Account;
    list: () => Burner[];
    select: (address: string) => void;
    deselect: () => void;
    remove: (address: string) => void;
    checkIsDeployed: (address: string, deployTx?: string) => Promise<boolean>;
    create: (options?: BurnerCreateOptions) => Promise<Account>;
    listConnectors: () => BurnerConnector[];
    clear: () => void;
    account: Account | null;
    isDeploying: boolean;
    count: number;
    copyToClipboard: () => Promise<void>;
    applyFromClipboard: () => Promise<void>;
    generateAddressFromSeed: (options?: BurnerCreateOptions) => string;
};

declare const useBurnerWindowObject: (burnerManager?: BurnerManager) => {
    isInitialized: boolean;
    isError: boolean;
    error: string | undefined;
};

declare const usePredeployedWindowObject: (predeployedManager?: PredeployedManager) => {
    isInitialized: boolean;
    isError: boolean;
    error: string | undefined;
};

/**
 * A class to manage Predeployed accounts.
 * This class exposes methods and properties to manage Predeployed accounts.
 * This class uses LocalStorage to store the Predeployed accounts.
 *
 * @example
 *
 * ```ts
 * export const createPredeployed = async () => {
 *     const rpcProvider = new RpcProvider({
 *          nodeUrl: import.meta.env.VITE_PUBLIC_NODE_URL!,
 *    });
 *
 *   const predeployedManager = new PredeployedManager({
 *      rpcProvider,
 *      predeployedAccounts: [
 *       {
 *           name: "Deployer",
 *           address: "0x6162896d1d7ab204c7ccac6dd5f8e9e7c25ecd5ae4fcb4ad32e57786bb46e03",
 *           privateKey: "0x1800000000300000180000000000030000000000003006001800006600",
 *           active: true
 *       },
 *       {
 *           name: "Treasury",
 *           address: "0xe29882a1fcba1e7e10cad46212257fea5c752a4f9b1b1ec683c503a2cf5c8a",
 *           privateKey: "0x14d6672dcb4b77ca36a887e9a11cd9d637d5012468175829e9c6e770c61642",
 *           active: false
 *       }
 *      ]
 *   });
 *
 *
 *  await predeployedManager.init();
 *
 *  return predeployedManager
 * };
 *
 *
 */
declare class PredeployedManager {
    provider: RpcProvider;
    chainId: string;
    account: Account | null;
    predeployedAccounts: PredeployedAccount[];
    isInitialized: boolean;
    constructor({ rpcProvider, predeployedAccounts, }: PredeployedManagerOptions);
    private getStorageKey;
    private getStorage;
    private setActiveAccount;
    init(): Promise<void>;
    list(): Predeployed[];
    select(address: string): void;
    get(address: string): Account;
    delete(address: string): void;
    clear(): void;
    getActiveAccount(): Account | null;
}

/**
 * Pre-funds a given account by initiating a transfer transaction.
 *
 * @param address - The destination address to which funds are to be transferred.
 * @param account - The source account from which funds will be deducted.
 * @param feeTokenAddress - The Ethereum contract address responsible for the transfer.
 *                             If not provided, defaults to KATANA_ETH_CONTRACT_ADDRESS.
 *
 * @returns - Returns the result of the transfer transaction, typically including transaction details.
 *
 * @throws - Throws an error if the transaction does not complete successfully.
 */
declare const prefundAccount: (address: string, account: AccountInterface, feeTokenAddress: string, prefundAmount: string, maxFee: number) => Promise<any>;

export { type Burner, type BurnerAccount, BurnerConnector, BurnerContext, type BurnerCreateOptions, type BurnerKeys, BurnerManager, type BurnerManagerOptions, BurnerProvider, type BurnerRecord, type BurnerStorage, DojoBurnerStarknetWindowObject, DojoPredeployedStarknetWindowObject, type Predeployed, type PredeployedAccount, PredeployedManager, type PredeployedManagerOptions, type PredeployedStorage, katanaIcon, prefundAccount, useBurner, useBurnerManager, useBurnerWindowObject, usePredeployedWindowObject };

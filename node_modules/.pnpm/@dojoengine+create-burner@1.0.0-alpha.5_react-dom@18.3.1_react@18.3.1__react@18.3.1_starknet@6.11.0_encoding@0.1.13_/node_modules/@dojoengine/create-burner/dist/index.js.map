{"version":3,"sources":["../src/connectors/burner.ts","../src/connectors/icons.ts","../src/connectors/dojoBurnerSWO.ts","../src/connectors/dojoPredeployedSWO.ts","../src/context/burnerProvider.tsx","../src/hooks/useBurner.ts","../src/manager/burnerManager.ts","../src/utils/storage.ts","../src/utils/keyDerivation.ts","../src/manager/prefundAccount.ts","../src/hooks/useBurnerManager.ts","../src/hooks/useBurnerWindowObject.ts","../src/hooks/usePredeployedWindowObject.ts","../src/manager/predeployedManager.ts"],"sourcesContent":["import { Connector } from \"@starknet-react/core\";\nimport { Account, AccountInterface, shortString } from \"starknet\";\nimport { katanaIcon } from \"./icons\";\n\n/** Burner connector options. */\ninterface BurnerConnectorOptions {\n    /** The connector id. */\n    id: string;\n    /** Connector human readable name. */\n    name?: string;\n    /** Connector icons. */\n    icon?: ConnectorIcons;\n}\n\n/** Non exported types from @starknet-react/core*/\n\n/** Connector icons, as base64 encoded svg. */\ntype ConnectorIcons = {\n    /** Dark-mode icon. */\n    dark?: string;\n    /** Light-mode icon. */\n    light?: string;\n};\n/** Connector data. */\ntype ConnectorData = {\n    /** Connector account. */\n    account?: string;\n    /** Connector network. */\n    chainId?: bigint;\n};\n\n/**\n *\n * @class BurnerConnector\n *\n * @description Extends the Connector class and implements the AccountInterface.\n *             This class is used to connect to the Burner Wallet.\n *\n *\n */\nexport class BurnerConnector extends Connector {\n    private _options: BurnerConnectorOptions;\n    private _account: AccountInterface | Account;\n\n    constructor(\n        options: BurnerConnectorOptions,\n        account: AccountInterface | Account\n    ) {\n        super();\n\n        this._options = options;\n        this._account = account;\n    }\n\n    available(): boolean {\n        return true;\n    }\n\n    async ready(): Promise<boolean> {\n        return Promise.resolve(true);\n    }\n\n    async connect(): Promise<ConnectorData> {\n        if (!this._account) {\n            throw new Error(\"account not found\");\n        }\n\n        const chainId = await this.chainId();\n\n        return Promise.resolve({\n            account: this._account.address,\n            chainId,\n        });\n    }\n\n    async disconnect(): Promise<void> {\n        Promise.resolve(this._account == null);\n    }\n\n    async account(): Promise<AccountInterface> {\n        return Promise.resolve(this._account);\n    }\n\n    async chainId(): Promise<bigint> {\n        const chainId = await this._account.getChainId();\n\n        return Promise.resolve(BigInt(shortString.encodeShortString(chainId)));\n    }\n\n    get id(): string {\n        return this._options.id;\n    }\n\n    get name(): string {\n        return this._options.name || \"Dojo Burner\";\n    }\n\n    get icon(): ConnectorIcons {\n        return (\n            this._options.icon || {\n                light: katanaIcon,\n                dark: katanaIcon,\n            }\n        );\n    }\n}\n","export const katanaIcon =\n    \"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzYgMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0xOC4yNzk4IDEzLjU4NzNDMTkuNjE5OCAxMy41ODczIDIwLjcwNjEgMTIuNTAwOCAyMC43MDYxIDExLjE2MDVDMjAuNzA2MSA5LjgyMDE3IDE5LjYxOTggOC43MzM2NCAxOC4yNzk4IDguNzMzNjRDMTYuOTM5OCA4LjczMzY0IDE1Ljg1MzUgOS44MjAxNyAxNS44NTM1IDExLjE2MDVDMTUuODUzNSAxMi41MDA4IDE2LjkzOTggMTMuNTg3MyAxOC4yNzk4IDEzLjU4NzNaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNS40MTAxNiAyLjc5NDhIMzEuMTUzOVYzLjg4NTEyQzMxLjE1MzkgNC4wODA0NiAzMS4wNzE4IDQuMjY0MjMgMzAuOTMxMiA0LjM5MzEyTDI4LjYyNiA2LjQ2NDRDMjguMzI1MSA2LjgwMDQxIDI3LjkxMSA2Ljk5MTk0IDI3LjQ4MTIgNi45OTE5NEgyNS42NTI3QzI1LjY1MjcgNi45OTE5NCAyNS42NDg4IDguNTA3NTUgMjUuNjQ4OCA5LjM5MjY1QzI1LjY0ODggMTAuMjc3NiAyNS4yODY1IDExLjIzMzIgMjUuMjg2NSAxMS4yMzMyTDI1LjUzMzQgMTEuNDgwMkMyNS43OTc5IDExLjExNyAyNi45NjY4IDkuNjc2NjQgMjcuNzQzIDkuNjc2NjRMMzAuNjc3MiA5LjY2MTA0VjEzLjQwNDhMMjUuNjQ4OCAxMy40NjM1VjIwLjc5NDhMMjQuNzY5NyAxOS45MTk0QzIzLjc2NzggMTguOTIzMyAyMi43NjQyIDE3LjkyODkgMjEuNzY1MiAxNi45Mjk5VjkuOTE1MDlDMjEuNzY1MiA4Ljg3MDU2IDIxLjk5NjkgOC4wMjA4MiAyMi4yMTAxIDcuMDg3NTlMMjIuMjEwNSA3LjA4NTY4TDIyLjIxMTkgNy4wNzk3NEwyMi4yMTM0IDcuMDczOUMyMi4yMTU0IDcuMDY2NjggMjIuMjE3MSA3LjA2MDMxIDIyLjIxNjcgNy4wNTM0MUMyMi4yMTY0IDcuMDQ3NzggMjIuMjE0NyA3LjA0MTgzIDIyLjIxMDUgNy4wMzQ5M0MyMi4xODQgNi45OTUwMiAyMi4wNzQ3IDYuOTU1MiAyMS45NzA2IDYuOTM1MjRDMjEuODkxIDYuOTIwMDYgMjEuODE0NyA2LjkxNjQ1IDIxLjc4MDggNi45MzMzM0MyMS4yMjMxIDcuMjA1MiAyMC42MzA4IDcuMzA2NjcgMjAuMDE2NiA3LjMxNzEyQzE4Ljg2MDcgNy4zMzY2MyAxNy43MDIgNy4zMzY0NSAxNi41NDYgNy4zMTcxMkMxNS45MzIzIDcuMzA2NjQgMTUuMzQwNCA3LjIwNDk2IDE0Ljc4MzIgNi45MzMzM0MxNC43MDUxIDYuODk0MjYgMTQuNDAwMyA2Ljk2NDU1IDE0LjM1MzUgNy4wMzQ5M0MxNC4zNDE3IDcuMDU0NDcgMTQuMzQ5NSA3LjA2NjE1IDE0LjM1MzUgNy4wODU2OEwxNC4zNTM5IDcuMDg3NTlDMTQuNTY3IDguMDIwNDIgMTQuNzk4OCA4Ljg3OTY5IDE0Ljc5ODggOS45MTUwOVYxNi45Mjk5QzEzLjUwNzQgMTguMjIxMyAxMi4yMDkzIDE5LjUwNiAxMC45MTUyIDIwLjc5NDhWMTMuNDYzNUw1Ljg4Njg0IDEzLjQwNDhWOS42NjEwNEw4LjgyMTAzIDkuNjc2NjRDOS41OTcyMSA5LjY3NjY0IDEwLjc2NjEgMTEuMTE3IDExLjAzMDYgMTEuNDgwMkwxMS4yNzc1IDExLjIzMzJDMTEuMjc3NSAxMS4yMzMyIDEwLjkxNTIgMTAuMjc3NiAxMC45MTUyIDkuMzkyNjVDMTAuOTE1MiA4LjUwNzU1IDEwLjkxMTMgNi45OTE5NCAxMC45MTEzIDYuOTkxOTRIOS4wODI3OEM4LjY1MzAzIDYuOTkxOTQgOC4yMzg4OCA2LjgwMDQxIDcuOTM4MDYgNi40NjQ0TDUuNjMyODQgNC4zOTMxMkM1LjQ5MjIyIDQuMjY0MjMgNS40MTAxNiA0LjA4MDQ2IDUuNDEwMTYgMy44ODUxMlYyLjc5NDhaIiBmaWxsPSIjRkYyRjQyIi8+Cjwvc3ZnPgo=\";\n","import { IStarknetWindowObject } from \"get-starknet-core\";\nimport { AccountInterface, RpcProvider } from \"starknet\";\nimport { BurnerManager } from \"..\";\nimport { katanaIcon } from \"./icons\";\n\nconst ID = \"dojoburner\";\nconst NAME = \"Dojo Burner\";\nconst VERSION = \"0.0.1\";\n\nexport class DojoBurnerStarknetWindowObject implements IStarknetWindowObject {\n    id = ID;\n    name = NAME;\n    icon = katanaIcon;\n    account?: AccountInterface = undefined;\n    provider?: RpcProvider = undefined;\n    selectedAddress?: string = undefined;\n    chainId?: string = undefined;\n    isConnected = false;\n    version = VERSION;\n    //\n    burnerManager: BurnerManager;\n\n    constructor(burnerManager: BurnerManager) {\n        if (!burnerManager.isInitialized) {\n            throw new Error(\"burnerManager should be initialized\");\n        }\n\n        this.burnerManager = burnerManager;\n\n        this.chainId = this.burnerManager.chainId;\n        this.provider = this.burnerManager.provider;\n\n        const activeAccount = this.burnerManager.getActiveAccount();\n\n        this.account = activeAccount ? activeAccount : undefined;\n        this.selectedAddress = this.account?.address;\n    }\n\n    ///@ts-ignore\n    async request(call: any) {\n        //console.log(\"request\", call);\n    }\n\n    ///@ts-ignore\n    async enable({ starknetVersion = \"v5\" } = {}) {\n        //console.log(\"enable\");\n        if (!this.burnerManager) {\n            // try to wait\n            await new Promise((r) => setTimeout(r, 1500));\n        }\n\n        // retrieve active account\n        const activeAccount = this.burnerManager?.getActiveAccount();\n        this.account = activeAccount ? activeAccount : undefined;\n\n        if (!this.account) {\n            this.account = await this.burnerManager?.create();\n        }\n        if (!this.account) {\n            this.isConnected = false;\n            return [];\n        }\n\n        this.isConnected = true;\n\n        return [this.account.address];\n    }\n\n    async isPreauthorized() {\n        return true;\n    }\n\n    ///@ts-ignore\n    on = (event: any, handleEvent: any) => {\n        //console.log(\"on\", event);\n    };\n\n    ///@ts-ignore\n    off = (event: any, handleEvent: any) => {\n        //console.log(\"off\", event);\n    };\n\n    /** @returns {string} the connector id */\n    static getId(): string {\n        return ID;\n    }\n\n    /** @returns {string} the connector name */\n    static getName(): string {\n        return NAME;\n    }\n}\n","import { IStarknetWindowObject } from \"get-starknet-core\";\nimport { AccountInterface, RpcProvider } from \"starknet\";\nimport { PredeployedManager } from \"..\";\nimport { katanaIcon } from \"./icons\";\n\nconst ID = \"dojopredeployed\";\nconst NAME = \"Dojo Predeployed\";\nconst VERSION = \"0.0.1\";\n\nexport class DojoPredeployedStarknetWindowObject\n    implements IStarknetWindowObject\n{\n    id = ID;\n    name = NAME;\n    icon = katanaIcon;\n    account?: AccountInterface = undefined;\n    provider?: RpcProvider = undefined;\n    selectedAddress?: string = undefined;\n    chainId?: string = undefined;\n    isConnected = false;\n    version = VERSION;\n    //\n    predeployedManager: PredeployedManager;\n\n    constructor(predeployedManager: PredeployedManager) {\n        this.predeployedManager = predeployedManager;\n\n        this.chainId = this.predeployedManager.chainId;\n        this.provider = this.predeployedManager.provider;\n\n        const activeAccount = this.predeployedManager.getActiveAccount();\n\n        this.account = activeAccount ? activeAccount : undefined;\n        this.selectedAddress = this.account?.address;\n    }\n\n    ///@ts-ignore\n    async request(call: any) {\n        //console.log(\"request\", call);\n    }\n\n    ///@ts-ignore\n    async enable({ starknetVersion = \"v5\" } = {}) {\n        //console.log(\"enable\");\n        if (!this.predeployedManager) {\n            // try to wait\n            await new Promise((r) => setTimeout(r, 1500));\n        }\n\n        // retrieve active account\n        const activeAccount = this.predeployedManager?.getActiveAccount();\n        this.account = activeAccount ? activeAccount : undefined;\n\n        if (!this.account) {\n            // try to select first account\n            const predeployed = this.predeployedManager?.list();\n            if (predeployed && predeployed?.length > 0) {\n                //select first\n                this.predeployedManager?.select(predeployed[0].address);\n\n                // retrieve active account\n                const activeAccount =\n                    this.predeployedManager?.getActiveAccount();\n                this.account = activeAccount ? activeAccount : undefined;\n            }\n        }\n\n        if (!this.account) {\n            this.isConnected = false;\n            return [];\n        }\n\n        this.isConnected = true;\n\n        return [this.account.address];\n    }\n\n    async isPreauthorized() {\n        return true;\n    }\n\n    ///@ts-ignore\n    on = (event: any, handleEvent: any) => {\n        //console.log(\"on\", event);\n    };\n\n    ///@ts-ignore\n    off = (event: any, handleEvent: any) => {\n        //console.log(\"off\", event);\n    };\n\n    /** @returns {string} the connector id */\n    static getId(): string {\n        return ID;\n    }\n\n    /** @returns {string} the connector name */\n    static getName(): string {\n        return NAME;\n    }\n}\n","import { ReactNode, createContext } from \"react\";\nimport { BurnerManagerOptions } from \"../types\";\n\nexport const BurnerContext = createContext<BurnerManagerOptions | null>(null);\n\n/**\n * Props for the BurnerProvider component {@link BurnerProvider}\n */\ninterface BurnerProviderProps {\n    children: ReactNode;\n    initOptions: BurnerManagerOptions;\n}\n\n/**\n * BurnerProvider\n *\n * @description This wraps the entire application in a context provider to allow for access to keep\n *            the burner manager options available to all components. Takes {@link BurnerProviderProps}.\n *\n * ```tsx\n * import { BurnerProvider } from '@dojoengine/create-burner';\n *\n * const initOptions = { ... };\n *\n * const App = () => {\n *    return (\n *       <BurnerProvider initOptions={initOptions}>\n *         <MyApp />\n *      </BurnerProvider>\n * )};\n * ```\n *\n * @param children\n * @param initOptions\n */\n\nexport const BurnerProvider = ({\n    children,\n    initOptions,\n}: BurnerProviderProps): JSX.Element => {\n    return (\n        <BurnerContext.Provider value={initOptions}>\n            {children}\n        </BurnerContext.Provider>\n    );\n};\n","import { useCallback, useContext, useEffect, useMemo, useState } from \"react\";\nimport { Account } from \"starknet\";\nimport { BurnerConnector } from \"..\";\nimport { BurnerContext } from \"../context\";\nimport { BurnerManager } from \"../manager/burnerManager\";\nimport { Burner, BurnerCreateOptions } from \"../types\";\n\n/**\n * A React hook to manage Burner accounts.\n * This hook exposes methods and properties to manage Burner accounts.\n * You need to use this within a {@link BurnerProvider} context.\n *\n * @example\n * ```tsx\n * import { useBurner } from \"@dojoengine/create-burner\";\n *\n * const MyComponent = () => {\n *   const { list, select, create } = useBurner();\n * const burners = list();\n *\n *   return (\n *     <div>\n *       <button onClick={() => create()}>Create Burner</button>\n *     {burners.map((burner) => (\n *       <button key={burner.address} onClick={() => select(burner.address)}>\n *         Select Burner\n *       </button>\n *    ))}\n *  </div>\n *  );\n * };\n * ```\n *\n * @returns An object with utility methods and properties.\n */\nexport const useBurner = () => {\n    const initParams = useContext(BurnerContext);\n\n    if (!initParams) {\n        throw new Error(\"useBurner must be used within a BurnerProvider\");\n    }\n\n    /** Initialize the BurnerManager with the provided options. */\n    const burnerManager = useMemo(\n        () => new BurnerManager(initParams),\n        [initParams]\n    );\n\n    const [account, setAccount] = useState<Account | null>(null);\n    const [count, setCount] = useState(0);\n    const [isDeploying, setIsDeploying] = useState(false);\n\n    // On mount, initialize the burner manager and set the active account.\n    useEffect(() => {\n        (async () => {\n            await burnerManager.init();\n            setAccount(burnerManager.getActiveAccount());\n            setCount(burnerManager.list().length);\n        })();\n    }, []);\n\n    /**\n     * Lists all the burners available in the storage.\n     *\n     * @returns An array of Burner accounts.\n     */\n    const list = useCallback((): Burner[] => {\n        return burnerManager.list();\n    }, [count]);\n\n    /**\n     * Selects and sets a burner as the active account.\n     *\n     * @param address - The address of the burner account to set as active.\n     */\n    const select = useCallback(\n        (address: string): void => {\n            burnerManager.select(address);\n            setAccount(burnerManager.getActiveAccount());\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Retrieves a burner account based on its address.\n     *\n     * @param address - The address of the burner account to retrieve.\n     * @returns The Burner account corresponding to the provided address.\n     */\n    const get = useCallback(\n        (address: string): Account => {\n            return burnerManager.get(address);\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Clears a burner account based on its address.\n     *\n     * @returns The Burner account corresponding to the provided address.\n     */\n    const clear = useCallback(() => {\n        burnerManager.clear();\n        setCount(0);\n    }, [burnerManager]);\n\n    /**\n     * Creates a new burner account and sets it as the active account.\n     *\n     * @param options - (optional) secret seed and index for deterministic accounts.\n     * @returns A promise that resolves to the newly created Burner account.\n     */\n    const create = useCallback(\n        async (options?: BurnerCreateOptions): Promise<Account> => {\n            burnerManager.setIsDeployingCallback(setIsDeploying);\n            const newAccount = await burnerManager.create(options);\n            setAccount(newAccount);\n            setCount((prev) => prev + 1);\n            return newAccount;\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Generates a list of BurnerConnector instances for each burner account. These can be added to Starknet React.\n     *\n     * @returns An array of BurnerConnector instances.\n     */\n    const listConnectors = useCallback((): BurnerConnector[] => {\n        // Retrieve all the burners.\n        const burners = list();\n\n        // Map each burner to its respective BurnerConnector instance.\n        return burners.map((burner) => {\n            return new BurnerConnector(\n                {\n                    id: burner.address,\n                    name: \"Dojo Burner\",\n                },\n                get(burner.address)\n            );\n        });\n    }, [burnerManager.isDeploying]);\n\n    /**\n     * Copy burners to clipboard\n     */\n    const copyToClipboard = useCallback(async () => {\n        await burnerManager.copyBurnersToClipboard();\n    }, [burnerManager]);\n\n    /**\n     * Set burners from clipboard\n     */\n    const applyFromClipboard = useCallback(async () => {\n        await burnerManager.setBurnersFromClipboard();\n        setAccount(burnerManager.getActiveAccount());\n        setCount(burnerManager.list().length);\n    }, [burnerManager]);\n\n    /**\n     * Returns a deterministic account addresses based on a seed and index.\n     *\n     * @param options - (optional) account secret seed and index\n     * @returns A deterministic Burner address\n     */\n    const generateAddressFromSeed = useCallback(\n        (options?: BurnerCreateOptions): string => {\n            const { address } = burnerManager.generateKeysAndAddress(options);\n            return address;\n        },\n        [burnerManager]\n    );\n\n    // Expose methods and properties for the consumers of this hook.\n    return {\n        get,\n        list,\n        select,\n        create,\n        listConnectors,\n        clear,\n        account,\n        isDeploying,\n        count,\n        copyToClipboard,\n        applyFromClipboard,\n        generateAddressFromSeed,\n    };\n};\n","import { KATANA_ETH_CONTRACT_ADDRESS } from \"@dojoengine/core\";\nimport {\n    Account,\n    CallData,\n    DeployAccountContractPayload,\n    ec,\n    hash,\n    RpcProvider,\n    shortString,\n    stark,\n} from \"starknet\";\nimport {\n    Burner,\n    BurnerCreateOptions,\n    BurnerManagerOptions,\n    BurnerStorage,\n    BurnerKeys,\n} from \"../types\";\nimport Storage from \"../utils/storage\";\nimport { derivePrivateKeyFromSeed } from \"../utils/keyDerivation\";\nimport { prefundAccount } from \"./prefundAccount\";\n\nexport const PREFUND_AMOUNT = \"10000000000000000\"; // 0.01 ETH\n\n/**\n * A class to manage Burner accounts.\n * This class exposes methods and properties to manage Burner accounts.\n * This class uses LocalStorage to store the Burner accounts.\n * You can use this class to build your own Burner Wallet in any js framework.\n *\n * @example\n *\n * ```ts\n * export const createBurner = async () => {\n *     const rpcProvider = new RpcProvider({\n *          nodeUrl: import.meta.env.VITE_PUBLIC_NODE_URL!,\n *    });\n *\n *  const masterAccount = new Account(\n *      rpcProvider,\n *      import.meta.env.VITE_PUBLIC_MASTER_ADDRESS!,\n *      import.meta.env.VITE_PUBLIC_MASTER_PRIVATE_KEY!,\n *      \"1\"\n *   );\n *\n *   const burnerManager = new BurnerManager({\n *      masterAccount,\n *      accountClassHash: import.meta.env.VITE_PUBLIC_ACCOUNT_CLASS_HASH!,\n *      rpcProvider,\n *   });\n *\n *   try {\n *           await burnerManager.init();\n *           if (burnerManager.list().length === 0) {\n *                 await burnerManager.create();\n *           }\n *       } catch (e) {\n *           console.log(e);\n *       }\n *   }\n *\n *  return {\n *      account: burnerManager.account as Account,\n *      burnerManager,\n *   };\n * };\n *\n *\n */\n\nexport class BurnerManager {\n    public masterAccount: Account;\n    public accountClassHash: string;\n    public feeTokenAddress: string;\n    public provider: RpcProvider;\n    public chainId: string = \"\";\n\n    public account: Account | null = null;\n    public isDeploying: boolean = false;\n    public isInitialized: boolean = false;\n\n    private setIsDeploying?: (isDeploying: boolean) => void;\n    private afterDeploying?: ({\n        account,\n        deployTx,\n    }: {\n        account: Account;\n        deployTx: string;\n    }) => Promise<void>;\n\n    constructor({\n        masterAccount,\n        accountClassHash,\n        feeTokenAddress = KATANA_ETH_CONTRACT_ADDRESS,\n        rpcProvider,\n    }: BurnerManagerOptions) {\n        this.masterAccount = masterAccount;\n        this.accountClassHash = accountClassHash;\n        this.feeTokenAddress = feeTokenAddress;\n        this.provider = rpcProvider;\n    }\n\n    public setIsDeployingCallback(\n        callback: (isDeploying: boolean) => void\n    ): void {\n        this.setIsDeploying = callback;\n    }\n\n    public setAfterDeployingCallback(\n        callback: ({\n            account,\n            deployTx,\n        }: {\n            account: Account;\n            deployTx: string;\n        }) => Promise<void>\n    ): void {\n        this.afterDeploying = callback;\n    }\n\n    private updateIsDeploying(status: boolean) {\n        this.isDeploying = status;\n        if (this.setIsDeploying) {\n            this.setIsDeploying(status);\n        }\n    }\n\n    private getBurnerKey(): string {\n        return `burners_${this.chainId}`;\n    }\n\n    private getBurnerStorage(): BurnerStorage {\n        return Storage.get(this.getBurnerKey()) || {};\n    }\n\n    private setActiveBurnerAccount(storage: BurnerStorage): void {\n        for (let address in storage) {\n            if (storage[address].active) {\n                this.account = new Account(\n                    this.provider,\n                    address,\n                    storage[address].privateKey,\n                    \"1\"\n                );\n                return;\n            }\n        }\n    }\n\n    public async isBurnerDeployed(\n        address: string,\n        deployTx?: string\n    ): Promise<boolean> {\n        if (deployTx) {\n            try {\n                const receipt =\n                    await this.masterAccount.getTransactionReceipt(deployTx);\n                return receipt !== null;\n            } catch {}\n        }\n        try {\n            // if account has a nonce, it was already deployed\n            const nonce = await this.masterAccount.getNonceForAddress(address);\n            return BigInt(nonce) > 0n;\n        } catch {}\n        return false;\n    }\n\n    public async init(keepNonDeployed = false): Promise<void> {\n        if (this.isInitialized) {\n            throw new Error(\"BurnerManager is already initialized\");\n        }\n        this.chainId = shortString.decodeShortString(\n            (await this.provider.getChainId()) as string\n        );\n        const storage = this.getBurnerStorage();\n        const addresses = Object.keys(storage);\n\n        const checks = addresses.map(async (address) => {\n            const isDeployed = await this.isBurnerDeployed(\n                address,\n                storage[address].deployTx\n            );\n            return isDeployed ? null : address;\n        });\n\n        const toRemove = (await Promise.all(checks)).filter(\n            (address): address is string => address !== null\n        );\n\n        toRemove.forEach((address) => {\n            if (!keepNonDeployed) {\n                console.log(\n                    `Removing non-deployed burner at address ${address}.`\n                );\n                delete storage[address];\n            }\n        });\n\n        if (Object.keys(storage).length) {\n            Storage.set(this.getBurnerKey(), storage);\n            this.setActiveBurnerAccount(storage); // Re-select the active burner account\n        } else {\n            this.clear();\n        }\n\n        this.isInitialized = true;\n    }\n\n    public list(): Burner[] {\n        const storage = this.getBurnerStorage();\n        return Object.keys(storage).map((address) => {\n            return {\n                address,\n                active: storage[address].active,\n                masterAccount: storage[address].masterAccount,\n                accountIndex: storage[address].accountIndex,\n            };\n        });\n    }\n\n    public select(address: string): void {\n        const storage = this.getBurnerStorage();\n        if (!storage[address]) {\n            throw new Error(\"burner not found\");\n        }\n\n        for (let addr in storage) {\n            storage[addr].active = false;\n        }\n        storage[address].active = true;\n\n        Storage.set(this.getBurnerKey(), storage);\n        this.account = new Account(\n            this.provider,\n            address,\n            storage[address].privateKey,\n            \"1\"\n        );\n    }\n\n    public deselect(): void {\n        const storage = this.getBurnerStorage();\n        for (let addr in storage) {\n            storage[addr].active = false;\n        }\n        Storage.set(this.getBurnerKey(), storage);\n        this.account = null;\n    }\n\n    public get(address: string): Account {\n        const storage = this.getBurnerStorage();\n        if (!storage[address]) {\n            throw new Error(\"burner not found\");\n        }\n\n        return new Account(\n            this.provider,\n            address,\n            storage[address].privateKey,\n            \"1\"\n        );\n    }\n\n    public delete(address: string) {\n        const storage = this.getBurnerStorage();\n        if (!storage[address]) {\n            throw new Error(\"burner not found\");\n        }\n\n        delete storage[address];\n\n        Storage.set(this.getBurnerKey(), storage);\n    }\n\n    clear(): void {\n        Storage.remove(this.getBurnerKey());\n    }\n\n    getActiveAccount(): Account | null {\n        const storage = this.getBurnerStorage();\n        for (let address in storage) {\n            if (storage[address].active) {\n                return new Account(\n                    this.provider,\n                    address,\n                    storage[address].privateKey,\n                    \"1\"\n                );\n            }\n        }\n        return null;\n    }\n\n    public generateKeysAndAddress(options?: BurnerCreateOptions): BurnerKeys {\n        const privateKey = options?.secret\n            ? derivePrivateKeyFromSeed(options.secret, options.index || 0)\n            : stark.randomAddress();\n        const publicKey = ec.starkCurve.getStarkKey(privateKey);\n        return {\n            privateKey,\n            publicKey,\n            address: hash.calculateContractAddressFromHash(\n                publicKey,\n                this.accountClassHash,\n                CallData.compile({ publicKey }),\n                0\n            ),\n        };\n    }\n\n    public async create(options?: BurnerCreateOptions): Promise<Account> {\n        if (!this.isInitialized) {\n            throw new Error(\"BurnerManager is not initialized\");\n        }\n        if (!this.masterAccount) {\n            throw new Error(\"master wallet account not found\");\n        }\n\n        this.updateIsDeploying(true);\n\n        const { privateKey, publicKey, address } =\n            this.generateKeysAndAddress(options);\n\n        const burner = new Account(this.provider, address, privateKey, \"1\");\n\n        let deployTx = \"\";\n\n        const isDeployed = await this.isBurnerDeployed(address);\n\n        if (!isDeployed) {\n            const payload: DeployAccountContractPayload = {\n                classHash: this.accountClassHash,\n                constructorCalldata: CallData.compile({ publicKey }),\n                addressSalt: publicKey,\n            };\n\n            let prefundAmount = BigInt(\n                options?.prefundedAmount || PREFUND_AMOUNT\n            );\n\n            // we could be doing this to save funds\n            // but ArgentX and Braavos always throw errors\n            // let prefundAmount = BigInt(options?.prefundedAmount ?? 0);\n            // try {\n            //     const { suggestedMaxFee } =\n            //         await this.masterAccount.estimateAccountDeployFee(payload, {\n            //             version: \"0x3\",\n            //         });\n            //     if (suggestedMaxFee > prefundAmount) {\n            //         prefundAmount = suggestedMaxFee;\n            //     }\n            // } catch (error) {\n            //     console.warn(error);\n            //     if (!prefundAmount) {\n            //         prefundAmount = BigInt(PREFUND_AMOUNT);\n            //     }\n            // }\n\n            if (prefundAmount > 0n) {\n                try {\n                    await prefundAccount(\n                        address,\n                        this.masterAccount,\n                        this.feeTokenAddress,\n                        prefundAmount.toString(),\n                        options?.maxFee || 0\n                    );\n                } catch (e) {\n                    console.error(`burner manager create() error:`, e);\n                    this.updateIsDeploying(false);\n                }\n            }\n\n            // deploy burner\n            try {\n                const { transaction_hash } =\n                    await burner.deployAccount(payload);\n                deployTx = transaction_hash;\n            } catch (error) {\n                this.updateIsDeploying(false);\n                throw error;\n            }\n\n            // wait to deploy\n            const receipt = await this.masterAccount.waitForTransaction(\n                deployTx,\n                {\n                    retryInterval: 100,\n                }\n            );\n            if (!receipt) {\n                throw new Error(\"Transaction did not complete successfully.\");\n            }\n        }\n\n        const storage = this.getBurnerStorage();\n        for (let address in storage) {\n            storage[address].active = false;\n        }\n\n        storage[address] = {\n            chainId: this.chainId,\n            privateKey,\n            publicKey,\n            deployTx,\n            masterAccount: this.masterAccount.address,\n            active: true,\n        };\n\n        if (options?.secret) {\n            storage[address].accountIndex = options.index;\n        }\n        if (options?.metadata) {\n            storage[address].metadata = options.metadata;\n        }\n\n        this.account = burner;\n        this.updateIsDeploying(false);\n        Storage.set(this.getBurnerKey(), storage);\n\n        if (this.afterDeploying) {\n            try {\n                await this.afterDeploying({ account: this.account, deployTx });\n            } catch (e: any) {\n                console.log(\"error on afterDeploying\", e);\n            }\n        }\n\n        return burner;\n    }\n\n    public async copyBurnersToClipboard(): Promise<void> {\n        const burners = this.getBurnerStorage();\n        try {\n            await navigator.clipboard.writeText(JSON.stringify(burners));\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    public async setBurnersFromClipboard(): Promise<void> {\n        try {\n            const text = await navigator.clipboard.readText();\n            const burners: BurnerStorage = JSON.parse(text);\n\n            // Assume no burner is active\n            let activeAddress: string | null = null;\n\n            // Iterate over the pasted burners to find the active one\n            for (const [address, burner] of Object.entries(burners)) {\n                if (burner.active) {\n                    activeAddress = address;\n                    break;\n                }\n            }\n\n            Storage.set(this.getBurnerKey(), burners);\n\n            // If there's an active burner, select it\n            if (activeAddress) {\n                this.select(activeAddress);\n            }\n        } catch (error) {\n            throw error;\n        }\n    }\n}\n","import Cookies from \"js-cookie\";\n\nconst hasLocalStorageSupport = (): boolean => {\n    try {\n        const testKey = \"__test__\";\n        if (typeof window !== \"undefined\") {\n            window.localStorage.setItem(testKey, testKey);\n            window.localStorage.removeItem(testKey);\n            return true;\n        }\n    } catch (e) {\n        return false;\n    }\n    return false;\n};\n\nconst isLocalStorage = hasLocalStorageSupport();\n\nconst safeParse = (data: string): any => {\n    try {\n        if (data === \"\") return null;\n        return JSON.parse(data);\n    } catch (e) {\n        console.error(\"Error parsing JSON data:\", e, \"Data:\", data);\n        return null;\n    }\n};\n\nconst Storage = {\n    keys: (): string[] => {\n        if (isLocalStorage) {\n            return Object.keys(window.localStorage);\n        }\n        return Object.keys(Cookies.get());\n    },\n\n    get: (key: string): any => {\n        if (isLocalStorage) {\n            return safeParse(window.localStorage.getItem(key) || \"\");\n        }\n        return safeParse(Cookies.get(key) || \"\");\n    },\n\n    set: (key: string, value: any): void => {\n        const data = JSON.stringify(value);\n        if (isLocalStorage) {\n            window.localStorage.setItem(key, data);\n        } else {\n            Cookies.set(key, data, {\n                secure: true,\n                sameSite: \"strict\",\n            });\n        }\n    },\n\n    remove: (key: string): void => {\n        if (isLocalStorage) {\n            window.localStorage.removeItem(key);\n        } else {\n            Cookies.remove(key);\n        }\n    },\n\n    clear: (): void => {\n        if (isLocalStorage) {\n            window.localStorage.clear();\n        } else {\n            const cookies = Cookies.get();\n            Object.keys(cookies).forEach((key) => Cookies.remove(key));\n        }\n    },\n};\n\nexport default Storage;\n","import { ec, encode, num } from \"starknet\";\nimport { HDKey } from \"@scure/bip32\";\n\n//\n// inspired by:\n// https://community.starknet.io/t/account-keys-and-addresses-derivation-standard/1230\n// https://github.com/argentlabs/argent-x/blob/main/packages/extension/src/background/keys/keyDerivation.ts\n// https://github.com/amanusk/starknet-cli-wallet/blob/main/src/keyDerivation.ts\n//\n// BIP-32 Hierarchical Deterministic Wallets\n// https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n//\n\nfunction getPathForIndex(index: number): string {\n    return `m/44'/9004'/0'/0/${index}`;\n}\n\n/**\n * @description derive an account KeyPair from a secret hash and index, allowing deterministic account creation\n * @param {string} secret a secret hash, like the signature of a message signed on the client, never stored!\n * @param {number} index sequential number identifying the account\n * @returns {KeyPair} the account address (pubKey) and private key (getPrivateKey)\n **/\nexport function derivePrivateKeyFromSeed(\n    secret: string,\n    index: number\n): string {\n    if (!secret) {\n        throw \"seed is undefined\";\n    }\n    const masterNode = HDKey.fromMasterSeed(num.hexToBytes(secret));\n    const childNode = masterNode.derive(getPathForIndex(index));\n    if (!childNode.privateKey) {\n        throw \"childNode.privateKey is undefined\";\n    }\n    const groundKey = ec.starkCurve.grindKey(childNode.privateKey);\n    return encode.addHexPrefix(groundKey);\n}\n","import {\n    AccountInterface,\n    CallData,\n    TransactionFinalityStatus,\n} from \"starknet\";\n\n/**\n * Pre-funds a given account by initiating a transfer transaction.\n *\n * @param address - The destination address to which funds are to be transferred.\n * @param account - The source account from which funds will be deducted.\n * @param feeTokenAddress - The Ethereum contract address responsible for the transfer.\n *                             If not provided, defaults to KATANA_ETH_CONTRACT_ADDRESS.\n *\n * @returns - Returns the result of the transfer transaction, typically including transaction details.\n *\n * @throws - Throws an error if the transaction does not complete successfully.\n */\nexport const prefundAccount = async (\n    address: string,\n    account: AccountInterface,\n    feeTokenAddress: string,\n    prefundAmount: string,\n    maxFee: number\n): Promise<any> => {\n    try {\n        // Configure the options for the transfer transaction\n        const transferOptions = {\n            contractAddress: feeTokenAddress,\n            entrypoint: \"transfer\",\n            calldata: CallData.compile([address, prefundAmount, \"0x0\"]),\n        };\n\n        // Retrieve the nonce for the account to avoid transaction collisions\n        const nonce = await account.getNonce();\n        // Initiate the transaction\n        const { transaction_hash } = await account.execute(\n            [transferOptions],\n            undefined,\n            {\n                nonce,\n                maxFee,\n            }\n        );\n\n        // Wait for the transaction to complete and check its status\n        const result = await account.waitForTransaction(transaction_hash, {\n            retryInterval: 1000,\n            successStates: [TransactionFinalityStatus.ACCEPTED_ON_L2],\n        });\n\n        if (!result) {\n            throw new Error(\"Transaction did not complete successfully.\");\n        }\n\n        return result;\n    } catch (error) {\n        console.error(error);\n        throw error;\n    }\n};\n","import { useCallback, useEffect, useState } from \"react\";\nimport { Account } from \"starknet\";\nimport { BurnerConnector } from \"..\";\nimport { BurnerManager } from \"../manager/burnerManager\";\nimport { Burner, BurnerCreateOptions } from \"../types\";\n\n/**\n * A React hook that takes the Burner Manager object avoiding the React Context.\n * Useful for building apps without React Context.\n *\n * @returns An object with utility methods and properties.\n */\nexport const useBurnerManager = ({\n    burnerManager,\n}: {\n    burnerManager: BurnerManager; // Accepts the BurnerManager class as an parameter\n}) => {\n    const [isError, setIsError] = useState(false);\n\n    // State to manage the current active account.\n    const [account, setAccount] = useState<Account | null>(null);\n    const [count, setCount] = useState(0);\n    const [isDeploying, setIsDeploying] = useState(false);\n\n    // On mount, set the active account and count the number of burners.\n    // burnerManager has to be initialized before the component mounts\n    useEffect(() => {\n        // allow null burner manager\n        // when the game rpc is unavailable, its impossible to create a valid Burner Manager and will result in client error\n        if (!burnerManager) {\n            setIsError(true);\n            console.error(\"BurnerManager object must be provided\");\n            return;\n        }\n        if (!burnerManager.isInitialized) {\n            throw new Error(\"BurnerManager must be intialized\");\n        }\n        if (!burnerManager.masterAccount) {\n            throw new Error(\"BurnerManager Master Account must be provided\");\n        }\n        setIsError(false);\n        (async () => {\n            setAccount(burnerManager.getActiveAccount());\n            setCount(burnerManager.list().length);\n        })();\n    }, [burnerManager]);\n\n    /**\n     * Lists all the burners available in the storage.\n     *\n     * @returns An array of Burner accounts.\n     */\n    const list = useCallback((): Burner[] => {\n        return burnerManager?.list() ?? [];\n    }, [count]);\n\n    /**\n     * Selects and sets a burner as the active account.\n     *\n     * @param address - The address of the burner account to set as active.\n     */\n    const select = useCallback(\n        (address: string): void => {\n            burnerManager.select(address);\n            setAccount(burnerManager.getActiveAccount());\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Deselects the active burner, account will be set to null. Useful to allow guests.\n     */\n    const deselect = useCallback((): void => {\n        burnerManager.deselect();\n        setAccount(null);\n    }, [burnerManager]);\n\n    /**\n     * Retrieves a burner account based on its address.\n     *\n     * @param address - The address of the burner account to retrieve.\n     * @returns The Burner account corresponding to the provided address.\n     */\n    const get = useCallback(\n        (address: string): Account => {\n            return burnerManager.get(address);\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Deletes a burner account based on its address.\n     *\n     * @param address - The address of the burner account to delete.\n     */\n    const remove = useCallback(\n        (address: string): void => {\n            burnerManager.delete(address);\n            setCount((prev) => Math.max(prev - 1, 0));\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Clears a burner account based on its address.\n     */\n    const clear = useCallback(() => {\n        burnerManager.clear();\n        setCount(0);\n    }, [burnerManager]);\n\n    /**\n     * Checks if an account has been deployed.\n     *\n     * @param address - The address of the burner account to check.\n     * @param deployTx - Optional deployment transaction hash.\n     * @returns True if account has been deployed.\n     */\n    const checkIsDeployed = useCallback(\n        async (address: string, deployTx?: string): Promise<boolean> => {\n            return burnerManager.isBurnerDeployed(address, deployTx);\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Creates a new burner account and sets it as the active account.\n     *\n     * @param options - (optional) secret seed and index for deterministic accounts.\n     * @returns A promise that resolves to the newly created Burner account.\n     */\n    const create = useCallback(\n        async (options?: BurnerCreateOptions): Promise<Account> => {\n            burnerManager.setIsDeployingCallback(setIsDeploying);\n            const newAccount = await burnerManager.create(options);\n            setAccount(newAccount);\n            setCount((prev) => prev + 1);\n            return newAccount;\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Generates a list of BurnerConnector instances for each burner account. These can be added to Starknet React.\n     *\n     * @returns An array of BurnerConnector instances.\n     */\n    const listConnectors = useCallback((): BurnerConnector[] => {\n        // Retrieve all the burners.\n        const burners = list();\n\n        // Map each burner to its respective BurnerConnector instance.\n        return burners.map((burner) => {\n            return new BurnerConnector(\n                {\n                    id: burner.address,\n                    name: \"Dojo Burner\",\n                },\n                get(burner.address)\n            );\n        });\n    }, [burnerManager?.isDeploying]);\n\n    /**\n     * Copy burners to clipboard\n     */\n    const copyToClipboard = useCallback(async () => {\n        await burnerManager.copyBurnersToClipboard();\n    }, [burnerManager]);\n\n    /**\n     * Set burners from clipboard\n     */\n    const applyFromClipboard = useCallback(async () => {\n        await burnerManager.setBurnersFromClipboard();\n        setAccount(burnerManager.getActiveAccount());\n        setCount(burnerManager.list().length);\n    }, [burnerManager]);\n\n    /**\n     * Returns a deterministic account addresses based on a seed and index.\n     *\n     * @param options - (optional) account secret seed and index\n     * @returns A deterministic Burner address\n     */\n    const generateAddressFromSeed = useCallback(\n        (options?: BurnerCreateOptions): string => {\n            const { address } = burnerManager.generateKeysAndAddress(options);\n            return address;\n        },\n        [burnerManager]\n    );\n\n    return {\n        isError,\n        get,\n        list,\n        select,\n        deselect,\n        remove,\n        checkIsDeployed,\n        create,\n        listConnectors,\n        clear,\n        account,\n        isDeploying,\n        count,\n        copyToClipboard,\n        applyFromClipboard,\n        generateAddressFromSeed,\n    };\n};\n","import { StarknetWindowObject } from \"get-starknet-core\";\nimport { useEffect, useState } from \"react\";\nimport { BurnerManager, DojoBurnerStarknetWindowObject } from \"..\";\n\nexport const useBurnerWindowObject = (burnerManager?: BurnerManager) => {\n    const [isInitialized, setIsInitialized] = useState(false);\n    const [isError, setIsError] = useState(false);\n    const [error, setError] = useState<string | undefined>();\n\n    useEffect(() => {\n        const initAsync = async () => {\n            if (!burnerManager) {\n                setIsInitialized(true);\n                return;\n            }\n\n            try {\n                if (!burnerManager.isInitialized) {\n                    await burnerManager.init();\n                }\n\n                const starknetWindowObject = new DojoBurnerStarknetWindowObject(\n                    burnerManager\n                );\n\n                const key = `starknet_${starknetWindowObject.id}`;\n                (window as any)[key] =\n                    starknetWindowObject as StarknetWindowObject;\n\n                setIsInitialized(true);\n            } catch (e: any) {\n                console.log(e);\n                setIsError(true);\n                setError(\"failed to initialize burnerManager\");\n            }\n        };\n\n        initAsync();\n    }, [burnerManager]);\n\n    return { isInitialized, isError, error };\n};\n","import { StarknetWindowObject } from \"get-starknet-core\";\nimport { useEffect, useState } from \"react\";\nimport { DojoPredeployedStarknetWindowObject, PredeployedManager } from \"..\";\n\nexport const usePredeployedWindowObject = (\n    predeployedManager?: PredeployedManager\n) => {\n    const [isInitialized, setIsInitialized] = useState(false);\n    const [isError, setIsError] = useState(false);\n    const [error, setError] = useState<string | undefined>();\n\n    useEffect(() => {\n        const initAsync = async () => {\n            if (!predeployedManager) {\n                setIsInitialized(true);\n                return;\n            }\n\n            try {\n                if (!predeployedManager.isInitialized) {\n                    await predeployedManager.init();\n                }\n\n                const starknetWindowObject =\n                    new DojoPredeployedStarknetWindowObject(predeployedManager);\n\n                const key = `starknet_${starknetWindowObject.id}`;\n                (window as any)[key as string] =\n                    starknetWindowObject as StarknetWindowObject;\n\n                setIsInitialized(true);\n            } catch (e: any) {\n                console.log(e);\n                setIsError(true);\n                setError(\"failed to initialize predeployedManager\");\n            }\n        };\n\n        initAsync();\n    }, [predeployedManager]);\n\n    return { isInitialized, isError, error };\n};\n","import { Account, RpcProvider, shortString } from \"starknet\";\nimport {\n    Predeployed,\n    PredeployedAccount,\n    PredeployedManagerOptions,\n    PredeployedStorage,\n} from \"../types\";\nimport Storage from \"../utils/storage\";\n\n/**\n * A class to manage Predeployed accounts.\n * This class exposes methods and properties to manage Predeployed accounts.\n * This class uses LocalStorage to store the Predeployed accounts.\n *\n * @example\n *\n * ```ts\n * export const createPredeployed = async () => {\n *     const rpcProvider = new RpcProvider({\n *          nodeUrl: import.meta.env.VITE_PUBLIC_NODE_URL!,\n *    });\n *\n *   const predeployedManager = new PredeployedManager({\n *      rpcProvider,\n *      predeployedAccounts: [\n *       {\n *           name: \"Deployer\",\n *           address: \"0x6162896d1d7ab204c7ccac6dd5f8e9e7c25ecd5ae4fcb4ad32e57786bb46e03\",\n *           privateKey: \"0x1800000000300000180000000000030000000000003006001800006600\",\n *           active: true\n *       },\n *       {\n *           name: \"Treasury\",\n *           address: \"0xe29882a1fcba1e7e10cad46212257fea5c752a4f9b1b1ec683c503a2cf5c8a\",\n *           privateKey: \"0x14d6672dcb4b77ca36a887e9a11cd9d637d5012468175829e9c6e770c61642\",\n *           active: false\n *       }\n *      ]\n *   });\n *\n *\n *  await predeployedManager.init();\n *\n *  return predeployedManager\n * };\n *\n *\n */\n\nexport class PredeployedManager {\n    public provider: RpcProvider;\n    public chainId: string = \"\";\n\n    public account: Account | null = null;\n    public predeployedAccounts: PredeployedAccount[] = [];\n    public isInitialized: boolean = false;\n\n    constructor({\n        rpcProvider,\n        predeployedAccounts,\n    }: PredeployedManagerOptions) {\n        this.provider = rpcProvider;\n        this.predeployedAccounts = predeployedAccounts;\n    }\n\n    private getStorageKey(): string {\n        return `predeployed_${this.chainId}`;\n    }\n\n    private getStorage(): PredeployedStorage {\n        return Storage.get(this.getStorageKey()) || {};\n    }\n\n    private setActiveAccount(storage: PredeployedStorage): void {\n        for (let address in storage) {\n            if (storage[address].active) {\n                this.account = new Account(\n                    this.provider,\n                    address,\n                    storage[address].privateKey,\n                    \"1\"\n                );\n                return;\n            }\n        }\n    }\n\n    public async init(): Promise<void> {\n        this.chainId = shortString.decodeShortString(\n            (await this.provider.getChainId()) as string\n        );\n\n        const storage = this.getStorage();\n        const addresses = Object.keys(storage);\n\n        if (addresses.length) {\n            Storage.set(this.getStorageKey(), storage);\n            this.setActiveAccount(storage); // Re-select the active account\n        } else {\n            // set predeployed accounts in storage\n            const storage = this.getStorage();\n            for (let predeployed of this.predeployedAccounts) {\n                storage[predeployed.address] = predeployed;\n            }\n            Storage.set(this.getStorageKey(), storage);\n        }\n\n        this.isInitialized = true;\n    }\n\n    public list(): Predeployed[] {\n        const storage = this.getStorage();\n        return Object.keys(storage).map((address) => {\n            return {\n                address,\n                name: storage[address].name,\n                active: storage[address].active,\n            };\n        });\n    }\n\n    public select(address: string): void {\n        const storage = this.getStorage();\n        if (!storage[address]) {\n            throw new Error(\"predeployed not found\");\n        }\n\n        for (let addr in storage) {\n            storage[addr].active = false;\n        }\n        storage[address].active = true;\n\n        Storage.set(this.getStorageKey(), storage);\n        this.account = new Account(\n            this.provider,\n            address,\n            storage[address].privateKey,\n            \"1\"\n        );\n    }\n\n    public get(address: string): Account {\n        const storage = this.getStorage();\n        if (!storage[address]) {\n            throw new Error(\"predeployed not found\");\n        }\n\n        return new Account(\n            this.provider,\n            address,\n            storage[address].privateKey,\n            \"1\"\n        );\n    }\n\n    public delete(address: string) {\n        const storage = this.getStorage();\n        if (!storage[address]) {\n            throw new Error(\"predeployed not found\");\n        }\n\n        delete storage[address];\n\n        Storage.set(this.getStorageKey(), storage);\n    }\n\n    clear(): void {\n        Storage.remove(this.getStorageKey());\n    }\n\n    getActiveAccount(): Account | null {\n        const storage = this.getStorage();\n        for (let address in storage) {\n            if (storage[address].active) {\n                return new Account(\n                    this.provider,\n                    address,\n                    storage[address].privateKey,\n                    \"1\"\n                );\n            }\n        }\n        return null;\n    }\n}\n"],"mappings":"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","names":["ID","NAME","VERSION","activeAccount","Account","CallData","ec","shortString","Account","shortString","ec","CallData","address","useCallback","useEffect","useState","useState","useEffect","useCallback","useEffect","useState","useState","useEffect","useEffect","useState","useState","useEffect","Account","shortString","PredeployedManager","Account","shortString","storage"]}
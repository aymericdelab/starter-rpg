// src/connectors/burner.ts
import { Connector } from "@starknet-react/core";
import { shortString } from "starknet";

// src/connectors/icons.ts
var katanaIcon = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzYgMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0xOC4yNzk4IDEzLjU4NzNDMTkuNjE5OCAxMy41ODczIDIwLjcwNjEgMTIuNTAwOCAyMC43MDYxIDExLjE2MDVDMjAuNzA2MSA5LjgyMDE3IDE5LjYxOTggOC43MzM2NCAxOC4yNzk4IDguNzMzNjRDMTYuOTM5OCA4LjczMzY0IDE1Ljg1MzUgOS44MjAxNyAxNS44NTM1IDExLjE2MDVDMTUuODUzNSAxMi41MDA4IDE2LjkzOTggMTMuNTg3MyAxOC4yNzk4IDEzLjU4NzNaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNS40MTAxNiAyLjc5NDhIMzEuMTUzOVYzLjg4NTEyQzMxLjE1MzkgNC4wODA0NiAzMS4wNzE4IDQuMjY0MjMgMzAuOTMxMiA0LjM5MzEyTDI4LjYyNiA2LjQ2NDRDMjguMzI1MSA2LjgwMDQxIDI3LjkxMSA2Ljk5MTk0IDI3LjQ4MTIgNi45OTE5NEgyNS42NTI3QzI1LjY1MjcgNi45OTE5NCAyNS42NDg4IDguNTA3NTUgMjUuNjQ4OCA5LjM5MjY1QzI1LjY0ODggMTAuMjc3NiAyNS4yODY1IDExLjIzMzIgMjUuMjg2NSAxMS4yMzMyTDI1LjUzMzQgMTEuNDgwMkMyNS43OTc5IDExLjExNyAyNi45NjY4IDkuNjc2NjQgMjcuNzQzIDkuNjc2NjRMMzAuNjc3MiA5LjY2MTA0VjEzLjQwNDhMMjUuNjQ4OCAxMy40NjM1VjIwLjc5NDhMMjQuNzY5NyAxOS45MTk0QzIzLjc2NzggMTguOTIzMyAyMi43NjQyIDE3LjkyODkgMjEuNzY1MiAxNi45Mjk5VjkuOTE1MDlDMjEuNzY1MiA4Ljg3MDU2IDIxLjk5NjkgOC4wMjA4MiAyMi4yMTAxIDcuMDg3NTlMMjIuMjEwNSA3LjA4NTY4TDIyLjIxMTkgNy4wNzk3NEwyMi4yMTM0IDcuMDczOUMyMi4yMTU0IDcuMDY2NjggMjIuMjE3MSA3LjA2MDMxIDIyLjIxNjcgNy4wNTM0MUMyMi4yMTY0IDcuMDQ3NzggMjIuMjE0NyA3LjA0MTgzIDIyLjIxMDUgNy4wMzQ5M0MyMi4xODQgNi45OTUwMiAyMi4wNzQ3IDYuOTU1MiAyMS45NzA2IDYuOTM1MjRDMjEuODkxIDYuOTIwMDYgMjEuODE0NyA2LjkxNjQ1IDIxLjc4MDggNi45MzMzM0MyMS4yMjMxIDcuMjA1MiAyMC42MzA4IDcuMzA2NjcgMjAuMDE2NiA3LjMxNzEyQzE4Ljg2MDcgNy4zMzY2MyAxNy43MDIgNy4zMzY0NSAxNi41NDYgNy4zMTcxMkMxNS45MzIzIDcuMzA2NjQgMTUuMzQwNCA3LjIwNDk2IDE0Ljc4MzIgNi45MzMzM0MxNC43MDUxIDYuODk0MjYgMTQuNDAwMyA2Ljk2NDU1IDE0LjM1MzUgNy4wMzQ5M0MxNC4zNDE3IDcuMDU0NDcgMTQuMzQ5NSA3LjA2NjE1IDE0LjM1MzUgNy4wODU2OEwxNC4zNTM5IDcuMDg3NTlDMTQuNTY3IDguMDIwNDIgMTQuNzk4OCA4Ljg3OTY5IDE0Ljc5ODggOS45MTUwOVYxNi45Mjk5QzEzLjUwNzQgMTguMjIxMyAxMi4yMDkzIDE5LjUwNiAxMC45MTUyIDIwLjc5NDhWMTMuNDYzNUw1Ljg4Njg0IDEzLjQwNDhWOS42NjEwNEw4LjgyMTAzIDkuNjc2NjRDOS41OTcyMSA5LjY3NjY0IDEwLjc2NjEgMTEuMTE3IDExLjAzMDYgMTEuNDgwMkwxMS4yNzc1IDExLjIzMzJDMTEuMjc3NSAxMS4yMzMyIDEwLjkxNTIgMTAuMjc3NiAxMC45MTUyIDkuMzkyNjVDMTAuOTE1MiA4LjUwNzU1IDEwLjkxMTMgNi45OTE5NCAxMC45MTEzIDYuOTkxOTRIOS4wODI3OEM4LjY1MzAzIDYuOTkxOTQgOC4yMzg4OCA2LjgwMDQxIDcuOTM4MDYgNi40NjQ0TDUuNjMyODQgNC4zOTMxMkM1LjQ5MjIyIDQuMjY0MjMgNS40MTAxNiA0LjA4MDQ2IDUuNDEwMTYgMy44ODUxMlYyLjc5NDhaIiBmaWxsPSIjRkYyRjQyIi8+Cjwvc3ZnPgo=";

// src/connectors/burner.ts
var BurnerConnector = class extends Connector {
  _options;
  _account;
  constructor(options, account) {
    super();
    this._options = options;
    this._account = account;
  }
  available() {
    return true;
  }
  async ready() {
    return Promise.resolve(true);
  }
  async connect() {
    if (!this._account) {
      throw new Error("account not found");
    }
    const chainId = await this.chainId();
    return Promise.resolve({
      account: this._account.address,
      chainId
    });
  }
  async disconnect() {
    Promise.resolve(this._account == null);
  }
  async account() {
    return Promise.resolve(this._account);
  }
  async chainId() {
    const chainId = await this._account.getChainId();
    return Promise.resolve(BigInt(shortString.encodeShortString(chainId)));
  }
  get id() {
    return this._options.id;
  }
  get name() {
    return this._options.name || "Dojo Burner";
  }
  get icon() {
    return this._options.icon || {
      light: katanaIcon,
      dark: katanaIcon
    };
  }
};

// src/connectors/dojoBurnerSWO.ts
var ID = "dojoburner";
var NAME = "Dojo Burner";
var VERSION = "0.0.1";
var DojoBurnerStarknetWindowObject = class {
  id = ID;
  name = NAME;
  icon = katanaIcon;
  account = void 0;
  provider = void 0;
  selectedAddress = void 0;
  chainId = void 0;
  isConnected = false;
  version = VERSION;
  //
  burnerManager;
  constructor(burnerManager) {
    if (!burnerManager.isInitialized) {
      throw new Error("burnerManager should be initialized");
    }
    this.burnerManager = burnerManager;
    this.chainId = this.burnerManager.chainId;
    this.provider = this.burnerManager.provider;
    const activeAccount = this.burnerManager.getActiveAccount();
    this.account = activeAccount ? activeAccount : void 0;
    this.selectedAddress = this.account?.address;
  }
  ///@ts-ignore
  async request(call) {
  }
  ///@ts-ignore
  async enable({ starknetVersion = "v5" } = {}) {
    if (!this.burnerManager) {
      await new Promise((r) => setTimeout(r, 1500));
    }
    const activeAccount = this.burnerManager?.getActiveAccount();
    this.account = activeAccount ? activeAccount : void 0;
    if (!this.account) {
      this.account = await this.burnerManager?.create();
    }
    if (!this.account) {
      this.isConnected = false;
      return [];
    }
    this.isConnected = true;
    return [this.account.address];
  }
  async isPreauthorized() {
    return true;
  }
  ///@ts-ignore
  on = (event, handleEvent) => {
  };
  ///@ts-ignore
  off = (event, handleEvent) => {
  };
  /** @returns {string} the connector id */
  static getId() {
    return ID;
  }
  /** @returns {string} the connector name */
  static getName() {
    return NAME;
  }
};

// src/connectors/dojoPredeployedSWO.ts
var ID2 = "dojopredeployed";
var NAME2 = "Dojo Predeployed";
var VERSION2 = "0.0.1";
var DojoPredeployedStarknetWindowObject = class {
  id = ID2;
  name = NAME2;
  icon = katanaIcon;
  account = void 0;
  provider = void 0;
  selectedAddress = void 0;
  chainId = void 0;
  isConnected = false;
  version = VERSION2;
  //
  predeployedManager;
  constructor(predeployedManager) {
    this.predeployedManager = predeployedManager;
    this.chainId = this.predeployedManager.chainId;
    this.provider = this.predeployedManager.provider;
    const activeAccount = this.predeployedManager.getActiveAccount();
    this.account = activeAccount ? activeAccount : void 0;
    this.selectedAddress = this.account?.address;
  }
  ///@ts-ignore
  async request(call) {
  }
  ///@ts-ignore
  async enable({ starknetVersion = "v5" } = {}) {
    if (!this.predeployedManager) {
      await new Promise((r) => setTimeout(r, 1500));
    }
    const activeAccount = this.predeployedManager?.getActiveAccount();
    this.account = activeAccount ? activeAccount : void 0;
    if (!this.account) {
      const predeployed = this.predeployedManager?.list();
      if (predeployed && predeployed?.length > 0) {
        this.predeployedManager?.select(predeployed[0].address);
        const activeAccount2 = this.predeployedManager?.getActiveAccount();
        this.account = activeAccount2 ? activeAccount2 : void 0;
      }
    }
    if (!this.account) {
      this.isConnected = false;
      return [];
    }
    this.isConnected = true;
    return [this.account.address];
  }
  async isPreauthorized() {
    return true;
  }
  ///@ts-ignore
  on = (event, handleEvent) => {
  };
  ///@ts-ignore
  off = (event, handleEvent) => {
  };
  /** @returns {string} the connector id */
  static getId() {
    return ID2;
  }
  /** @returns {string} the connector name */
  static getName() {
    return NAME2;
  }
};

// src/context/burnerProvider.tsx
import { createContext } from "react";
import { jsx } from "react/jsx-runtime";
var BurnerContext = createContext(null);
var BurnerProvider = ({
  children,
  initOptions
}) => {
  return /* @__PURE__ */ jsx(BurnerContext.Provider, { value: initOptions, children });
};

// src/hooks/useBurner.ts
import { useCallback, useContext, useEffect, useMemo, useState } from "react";

// src/manager/burnerManager.ts
import { KATANA_ETH_CONTRACT_ADDRESS } from "@dojoengine/core";
import {
  Account as Account2,
  CallData as CallData2,
  ec as ec2,
  hash,
  shortString as shortString2,
  stark
} from "starknet";

// src/utils/storage.ts
import Cookies from "js-cookie";
var hasLocalStorageSupport = () => {
  try {
    const testKey = "__test__";
    if (typeof window !== "undefined") {
      window.localStorage.setItem(testKey, testKey);
      window.localStorage.removeItem(testKey);
      return true;
    }
  } catch (e) {
    return false;
  }
  return false;
};
var isLocalStorage = hasLocalStorageSupport();
var safeParse = (data) => {
  try {
    if (data === "") return null;
    return JSON.parse(data);
  } catch (e) {
    console.error("Error parsing JSON data:", e, "Data:", data);
    return null;
  }
};
var Storage = {
  keys: () => {
    if (isLocalStorage) {
      return Object.keys(window.localStorage);
    }
    return Object.keys(Cookies.get());
  },
  get: (key) => {
    if (isLocalStorage) {
      return safeParse(window.localStorage.getItem(key) || "");
    }
    return safeParse(Cookies.get(key) || "");
  },
  set: (key, value) => {
    const data = JSON.stringify(value);
    if (isLocalStorage) {
      window.localStorage.setItem(key, data);
    } else {
      Cookies.set(key, data, {
        secure: true,
        sameSite: "strict"
      });
    }
  },
  remove: (key) => {
    if (isLocalStorage) {
      window.localStorage.removeItem(key);
    } else {
      Cookies.remove(key);
    }
  },
  clear: () => {
    if (isLocalStorage) {
      window.localStorage.clear();
    } else {
      const cookies = Cookies.get();
      Object.keys(cookies).forEach((key) => Cookies.remove(key));
    }
  }
};
var storage_default = Storage;

// src/utils/keyDerivation.ts
import { ec, encode, num } from "starknet";
import { HDKey } from "@scure/bip32";
function getPathForIndex(index) {
  return `m/44'/9004'/0'/0/${index}`;
}
function derivePrivateKeyFromSeed(secret, index) {
  if (!secret) {
    throw "seed is undefined";
  }
  const masterNode = HDKey.fromMasterSeed(num.hexToBytes(secret));
  const childNode = masterNode.derive(getPathForIndex(index));
  if (!childNode.privateKey) {
    throw "childNode.privateKey is undefined";
  }
  const groundKey = ec.starkCurve.grindKey(childNode.privateKey);
  return encode.addHexPrefix(groundKey);
}

// src/manager/prefundAccount.ts
import {
  CallData,
  TransactionFinalityStatus
} from "starknet";
var prefundAccount = async (address, account, feeTokenAddress, prefundAmount, maxFee) => {
  try {
    const transferOptions = {
      contractAddress: feeTokenAddress,
      entrypoint: "transfer",
      calldata: CallData.compile([address, prefundAmount, "0x0"])
    };
    const nonce = await account.getNonce();
    const { transaction_hash } = await account.execute(
      [transferOptions],
      void 0,
      {
        nonce,
        maxFee
      }
    );
    const result = await account.waitForTransaction(transaction_hash, {
      retryInterval: 1e3,
      successStates: [TransactionFinalityStatus.ACCEPTED_ON_L2]
    });
    if (!result) {
      throw new Error("Transaction did not complete successfully.");
    }
    return result;
  } catch (error) {
    console.error(error);
    throw error;
  }
};

// src/manager/burnerManager.ts
var PREFUND_AMOUNT = "10000000000000000";
var BurnerManager = class {
  masterAccount;
  accountClassHash;
  feeTokenAddress;
  provider;
  chainId = "";
  account = null;
  isDeploying = false;
  isInitialized = false;
  setIsDeploying;
  afterDeploying;
  constructor({
    masterAccount,
    accountClassHash,
    feeTokenAddress = KATANA_ETH_CONTRACT_ADDRESS,
    rpcProvider
  }) {
    this.masterAccount = masterAccount;
    this.accountClassHash = accountClassHash;
    this.feeTokenAddress = feeTokenAddress;
    this.provider = rpcProvider;
  }
  setIsDeployingCallback(callback) {
    this.setIsDeploying = callback;
  }
  setAfterDeployingCallback(callback) {
    this.afterDeploying = callback;
  }
  updateIsDeploying(status) {
    this.isDeploying = status;
    if (this.setIsDeploying) {
      this.setIsDeploying(status);
    }
  }
  getBurnerKey() {
    return `burners_${this.chainId}`;
  }
  getBurnerStorage() {
    return storage_default.get(this.getBurnerKey()) || {};
  }
  setActiveBurnerAccount(storage) {
    for (let address in storage) {
      if (storage[address].active) {
        this.account = new Account2(
          this.provider,
          address,
          storage[address].privateKey,
          "1"
        );
        return;
      }
    }
  }
  async isBurnerDeployed(address, deployTx) {
    if (deployTx) {
      try {
        const receipt = await this.masterAccount.getTransactionReceipt(deployTx);
        return receipt !== null;
      } catch {
      }
    }
    try {
      const nonce = await this.masterAccount.getNonceForAddress(address);
      return BigInt(nonce) > 0n;
    } catch {
    }
    return false;
  }
  async init(keepNonDeployed = false) {
    if (this.isInitialized) {
      throw new Error("BurnerManager is already initialized");
    }
    this.chainId = shortString2.decodeShortString(
      await this.provider.getChainId()
    );
    const storage = this.getBurnerStorage();
    const addresses = Object.keys(storage);
    const checks = addresses.map(async (address) => {
      const isDeployed = await this.isBurnerDeployed(
        address,
        storage[address].deployTx
      );
      return isDeployed ? null : address;
    });
    const toRemove = (await Promise.all(checks)).filter(
      (address) => address !== null
    );
    toRemove.forEach((address) => {
      if (!keepNonDeployed) {
        console.log(
          `Removing non-deployed burner at address ${address}.`
        );
        delete storage[address];
      }
    });
    if (Object.keys(storage).length) {
      storage_default.set(this.getBurnerKey(), storage);
      this.setActiveBurnerAccount(storage);
    } else {
      this.clear();
    }
    this.isInitialized = true;
  }
  list() {
    const storage = this.getBurnerStorage();
    return Object.keys(storage).map((address) => {
      return {
        address,
        active: storage[address].active,
        masterAccount: storage[address].masterAccount,
        accountIndex: storage[address].accountIndex
      };
    });
  }
  select(address) {
    const storage = this.getBurnerStorage();
    if (!storage[address]) {
      throw new Error("burner not found");
    }
    for (let addr in storage) {
      storage[addr].active = false;
    }
    storage[address].active = true;
    storage_default.set(this.getBurnerKey(), storage);
    this.account = new Account2(
      this.provider,
      address,
      storage[address].privateKey,
      "1"
    );
  }
  deselect() {
    const storage = this.getBurnerStorage();
    for (let addr in storage) {
      storage[addr].active = false;
    }
    storage_default.set(this.getBurnerKey(), storage);
    this.account = null;
  }
  get(address) {
    const storage = this.getBurnerStorage();
    if (!storage[address]) {
      throw new Error("burner not found");
    }
    return new Account2(
      this.provider,
      address,
      storage[address].privateKey,
      "1"
    );
  }
  delete(address) {
    const storage = this.getBurnerStorage();
    if (!storage[address]) {
      throw new Error("burner not found");
    }
    delete storage[address];
    storage_default.set(this.getBurnerKey(), storage);
  }
  clear() {
    storage_default.remove(this.getBurnerKey());
  }
  getActiveAccount() {
    const storage = this.getBurnerStorage();
    for (let address in storage) {
      if (storage[address].active) {
        return new Account2(
          this.provider,
          address,
          storage[address].privateKey,
          "1"
        );
      }
    }
    return null;
  }
  generateKeysAndAddress(options) {
    const privateKey = options?.secret ? derivePrivateKeyFromSeed(options.secret, options.index || 0) : stark.randomAddress();
    const publicKey = ec2.starkCurve.getStarkKey(privateKey);
    return {
      privateKey,
      publicKey,
      address: hash.calculateContractAddressFromHash(
        publicKey,
        this.accountClassHash,
        CallData2.compile({ publicKey }),
        0
      )
    };
  }
  async create(options) {
    if (!this.isInitialized) {
      throw new Error("BurnerManager is not initialized");
    }
    if (!this.masterAccount) {
      throw new Error("master wallet account not found");
    }
    this.updateIsDeploying(true);
    const { privateKey, publicKey, address } = this.generateKeysAndAddress(options);
    const burner = new Account2(this.provider, address, privateKey, "1");
    let deployTx = "";
    const isDeployed = await this.isBurnerDeployed(address);
    if (!isDeployed) {
      const payload = {
        classHash: this.accountClassHash,
        constructorCalldata: CallData2.compile({ publicKey }),
        addressSalt: publicKey
      };
      let prefundAmount = BigInt(
        options?.prefundedAmount || PREFUND_AMOUNT
      );
      if (prefundAmount > 0n) {
        try {
          await prefundAccount(
            address,
            this.masterAccount,
            this.feeTokenAddress,
            prefundAmount.toString(),
            options?.maxFee || 0
          );
        } catch (e) {
          console.error(`burner manager create() error:`, e);
          this.updateIsDeploying(false);
        }
      }
      try {
        const { transaction_hash } = await burner.deployAccount(payload);
        deployTx = transaction_hash;
      } catch (error) {
        this.updateIsDeploying(false);
        throw error;
      }
      const receipt = await this.masterAccount.waitForTransaction(
        deployTx,
        {
          retryInterval: 100
        }
      );
      if (!receipt) {
        throw new Error("Transaction did not complete successfully.");
      }
    }
    const storage = this.getBurnerStorage();
    for (let address2 in storage) {
      storage[address2].active = false;
    }
    storage[address] = {
      chainId: this.chainId,
      privateKey,
      publicKey,
      deployTx,
      masterAccount: this.masterAccount.address,
      active: true
    };
    if (options?.secret) {
      storage[address].accountIndex = options.index;
    }
    if (options?.metadata) {
      storage[address].metadata = options.metadata;
    }
    this.account = burner;
    this.updateIsDeploying(false);
    storage_default.set(this.getBurnerKey(), storage);
    if (this.afterDeploying) {
      try {
        await this.afterDeploying({ account: this.account, deployTx });
      } catch (e) {
        console.log("error on afterDeploying", e);
      }
    }
    return burner;
  }
  async copyBurnersToClipboard() {
    const burners = this.getBurnerStorage();
    try {
      await navigator.clipboard.writeText(JSON.stringify(burners));
    } catch (error) {
      throw error;
    }
  }
  async setBurnersFromClipboard() {
    try {
      const text = await navigator.clipboard.readText();
      const burners = JSON.parse(text);
      let activeAddress = null;
      for (const [address, burner] of Object.entries(burners)) {
        if (burner.active) {
          activeAddress = address;
          break;
        }
      }
      storage_default.set(this.getBurnerKey(), burners);
      if (activeAddress) {
        this.select(activeAddress);
      }
    } catch (error) {
      throw error;
    }
  }
};

// src/hooks/useBurner.ts
var useBurner = () => {
  const initParams = useContext(BurnerContext);
  if (!initParams) {
    throw new Error("useBurner must be used within a BurnerProvider");
  }
  const burnerManager = useMemo(
    () => new BurnerManager(initParams),
    [initParams]
  );
  const [account, setAccount] = useState(null);
  const [count, setCount] = useState(0);
  const [isDeploying, setIsDeploying] = useState(false);
  useEffect(() => {
    (async () => {
      await burnerManager.init();
      setAccount(burnerManager.getActiveAccount());
      setCount(burnerManager.list().length);
    })();
  }, []);
  const list = useCallback(() => {
    return burnerManager.list();
  }, [count]);
  const select = useCallback(
    (address) => {
      burnerManager.select(address);
      setAccount(burnerManager.getActiveAccount());
    },
    [burnerManager]
  );
  const get = useCallback(
    (address) => {
      return burnerManager.get(address);
    },
    [burnerManager]
  );
  const clear = useCallback(() => {
    burnerManager.clear();
    setCount(0);
  }, [burnerManager]);
  const create = useCallback(
    async (options) => {
      burnerManager.setIsDeployingCallback(setIsDeploying);
      const newAccount = await burnerManager.create(options);
      setAccount(newAccount);
      setCount((prev) => prev + 1);
      return newAccount;
    },
    [burnerManager]
  );
  const listConnectors = useCallback(() => {
    const burners = list();
    return burners.map((burner) => {
      return new BurnerConnector(
        {
          id: burner.address,
          name: "Dojo Burner"
        },
        get(burner.address)
      );
    });
  }, [burnerManager.isDeploying]);
  const copyToClipboard = useCallback(async () => {
    await burnerManager.copyBurnersToClipboard();
  }, [burnerManager]);
  const applyFromClipboard = useCallback(async () => {
    await burnerManager.setBurnersFromClipboard();
    setAccount(burnerManager.getActiveAccount());
    setCount(burnerManager.list().length);
  }, [burnerManager]);
  const generateAddressFromSeed = useCallback(
    (options) => {
      const { address } = burnerManager.generateKeysAndAddress(options);
      return address;
    },
    [burnerManager]
  );
  return {
    get,
    list,
    select,
    create,
    listConnectors,
    clear,
    account,
    isDeploying,
    count,
    copyToClipboard,
    applyFromClipboard,
    generateAddressFromSeed
  };
};

// src/hooks/useBurnerManager.ts
import { useCallback as useCallback2, useEffect as useEffect2, useState as useState2 } from "react";
var useBurnerManager = ({
  burnerManager
}) => {
  const [isError, setIsError] = useState2(false);
  const [account, setAccount] = useState2(null);
  const [count, setCount] = useState2(0);
  const [isDeploying, setIsDeploying] = useState2(false);
  useEffect2(() => {
    if (!burnerManager) {
      setIsError(true);
      console.error("BurnerManager object must be provided");
      return;
    }
    if (!burnerManager.isInitialized) {
      throw new Error("BurnerManager must be intialized");
    }
    if (!burnerManager.masterAccount) {
      throw new Error("BurnerManager Master Account must be provided");
    }
    setIsError(false);
    (async () => {
      setAccount(burnerManager.getActiveAccount());
      setCount(burnerManager.list().length);
    })();
  }, [burnerManager]);
  const list = useCallback2(() => {
    return burnerManager?.list() ?? [];
  }, [count]);
  const select = useCallback2(
    (address) => {
      burnerManager.select(address);
      setAccount(burnerManager.getActiveAccount());
    },
    [burnerManager]
  );
  const deselect = useCallback2(() => {
    burnerManager.deselect();
    setAccount(null);
  }, [burnerManager]);
  const get = useCallback2(
    (address) => {
      return burnerManager.get(address);
    },
    [burnerManager]
  );
  const remove = useCallback2(
    (address) => {
      burnerManager.delete(address);
      setCount((prev) => Math.max(prev - 1, 0));
    },
    [burnerManager]
  );
  const clear = useCallback2(() => {
    burnerManager.clear();
    setCount(0);
  }, [burnerManager]);
  const checkIsDeployed = useCallback2(
    async (address, deployTx) => {
      return burnerManager.isBurnerDeployed(address, deployTx);
    },
    [burnerManager]
  );
  const create = useCallback2(
    async (options) => {
      burnerManager.setIsDeployingCallback(setIsDeploying);
      const newAccount = await burnerManager.create(options);
      setAccount(newAccount);
      setCount((prev) => prev + 1);
      return newAccount;
    },
    [burnerManager]
  );
  const listConnectors = useCallback2(() => {
    const burners = list();
    return burners.map((burner) => {
      return new BurnerConnector(
        {
          id: burner.address,
          name: "Dojo Burner"
        },
        get(burner.address)
      );
    });
  }, [burnerManager?.isDeploying]);
  const copyToClipboard = useCallback2(async () => {
    await burnerManager.copyBurnersToClipboard();
  }, [burnerManager]);
  const applyFromClipboard = useCallback2(async () => {
    await burnerManager.setBurnersFromClipboard();
    setAccount(burnerManager.getActiveAccount());
    setCount(burnerManager.list().length);
  }, [burnerManager]);
  const generateAddressFromSeed = useCallback2(
    (options) => {
      const { address } = burnerManager.generateKeysAndAddress(options);
      return address;
    },
    [burnerManager]
  );
  return {
    isError,
    get,
    list,
    select,
    deselect,
    remove,
    checkIsDeployed,
    create,
    listConnectors,
    clear,
    account,
    isDeploying,
    count,
    copyToClipboard,
    applyFromClipboard,
    generateAddressFromSeed
  };
};

// src/hooks/useBurnerWindowObject.ts
import { useEffect as useEffect3, useState as useState3 } from "react";
var useBurnerWindowObject = (burnerManager) => {
  const [isInitialized, setIsInitialized] = useState3(false);
  const [isError, setIsError] = useState3(false);
  const [error, setError] = useState3();
  useEffect3(() => {
    const initAsync = async () => {
      if (!burnerManager) {
        setIsInitialized(true);
        return;
      }
      try {
        if (!burnerManager.isInitialized) {
          await burnerManager.init();
        }
        const starknetWindowObject = new DojoBurnerStarknetWindowObject(
          burnerManager
        );
        const key = `starknet_${starknetWindowObject.id}`;
        window[key] = starknetWindowObject;
        setIsInitialized(true);
      } catch (e) {
        console.log(e);
        setIsError(true);
        setError("failed to initialize burnerManager");
      }
    };
    initAsync();
  }, [burnerManager]);
  return { isInitialized, isError, error };
};

// src/hooks/usePredeployedWindowObject.ts
import { useEffect as useEffect4, useState as useState4 } from "react";
var usePredeployedWindowObject = (predeployedManager) => {
  const [isInitialized, setIsInitialized] = useState4(false);
  const [isError, setIsError] = useState4(false);
  const [error, setError] = useState4();
  useEffect4(() => {
    const initAsync = async () => {
      if (!predeployedManager) {
        setIsInitialized(true);
        return;
      }
      try {
        if (!predeployedManager.isInitialized) {
          await predeployedManager.init();
        }
        const starknetWindowObject = new DojoPredeployedStarknetWindowObject(predeployedManager);
        const key = `starknet_${starknetWindowObject.id}`;
        window[key] = starknetWindowObject;
        setIsInitialized(true);
      } catch (e) {
        console.log(e);
        setIsError(true);
        setError("failed to initialize predeployedManager");
      }
    };
    initAsync();
  }, [predeployedManager]);
  return { isInitialized, isError, error };
};

// src/manager/predeployedManager.ts
import { Account as Account3, shortString as shortString3 } from "starknet";
var PredeployedManager2 = class {
  provider;
  chainId = "";
  account = null;
  predeployedAccounts = [];
  isInitialized = false;
  constructor({
    rpcProvider,
    predeployedAccounts
  }) {
    this.provider = rpcProvider;
    this.predeployedAccounts = predeployedAccounts;
  }
  getStorageKey() {
    return `predeployed_${this.chainId}`;
  }
  getStorage() {
    return storage_default.get(this.getStorageKey()) || {};
  }
  setActiveAccount(storage) {
    for (let address in storage) {
      if (storage[address].active) {
        this.account = new Account3(
          this.provider,
          address,
          storage[address].privateKey,
          "1"
        );
        return;
      }
    }
  }
  async init() {
    this.chainId = shortString3.decodeShortString(
      await this.provider.getChainId()
    );
    const storage = this.getStorage();
    const addresses = Object.keys(storage);
    if (addresses.length) {
      storage_default.set(this.getStorageKey(), storage);
      this.setActiveAccount(storage);
    } else {
      const storage2 = this.getStorage();
      for (let predeployed of this.predeployedAccounts) {
        storage2[predeployed.address] = predeployed;
      }
      storage_default.set(this.getStorageKey(), storage2);
    }
    this.isInitialized = true;
  }
  list() {
    const storage = this.getStorage();
    return Object.keys(storage).map((address) => {
      return {
        address,
        name: storage[address].name,
        active: storage[address].active
      };
    });
  }
  select(address) {
    const storage = this.getStorage();
    if (!storage[address]) {
      throw new Error("predeployed not found");
    }
    for (let addr in storage) {
      storage[addr].active = false;
    }
    storage[address].active = true;
    storage_default.set(this.getStorageKey(), storage);
    this.account = new Account3(
      this.provider,
      address,
      storage[address].privateKey,
      "1"
    );
  }
  get(address) {
    const storage = this.getStorage();
    if (!storage[address]) {
      throw new Error("predeployed not found");
    }
    return new Account3(
      this.provider,
      address,
      storage[address].privateKey,
      "1"
    );
  }
  delete(address) {
    const storage = this.getStorage();
    if (!storage[address]) {
      throw new Error("predeployed not found");
    }
    delete storage[address];
    storage_default.set(this.getStorageKey(), storage);
  }
  clear() {
    storage_default.remove(this.getStorageKey());
  }
  getActiveAccount() {
    const storage = this.getStorage();
    for (let address in storage) {
      if (storage[address].active) {
        return new Account3(
          this.provider,
          address,
          storage[address].privateKey,
          "1"
        );
      }
    }
    return null;
  }
};
export {
  BurnerConnector,
  BurnerContext,
  BurnerManager,
  BurnerProvider,
  DojoBurnerStarknetWindowObject,
  DojoPredeployedStarknetWindowObject,
  PredeployedManager2 as PredeployedManager,
  katanaIcon,
  prefundAccount,
  useBurner,
  useBurnerManager,
  useBurnerWindowObject,
  usePredeployedWindowObject
};
//# sourceMappingURL=index.js.map
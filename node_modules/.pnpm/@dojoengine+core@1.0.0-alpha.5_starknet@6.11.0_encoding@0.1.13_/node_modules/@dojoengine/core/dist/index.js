// src/provider/DojoProvider.ts
import {
  RpcProvider,
  Contract,
  shortString
} from "starknet";

// src/provider/provider.ts
var Provider = class {
  // Store the address of the world.
  worldAddress;
  /**
   * Constructor: Initializes the Provider with a given world address.
   *
   * @param {string} worldAddress - The address of the world.
   */
  constructor(worldAddress) {
    this.worldAddress = worldAddress;
  }
  /**
   * Retrieves the stored world address.
   *
   * @returns {string} - The address of the world.
   */
  getWorldAddress() {
    return this.worldAddress;
  }
};

// src/logger/logger.ts
var NO_OP = (_message, ..._optionalParams) => {
};
var ConsoleLogger = class {
  info;
  warn;
  error;
  constructor(options) {
    const { level } = options || {};
    this.error = console.error.bind(console);
    if (level === "none") {
      this.error = NO_OP;
      this.warn = NO_OP;
      this.info = NO_OP;
    }
    if (level === "error") {
      this.warn = NO_OP;
      this.info = NO_OP;
      return;
    }
    this.warn = console.warn.bind(console);
    if (level === "warn") {
      this.info = NO_OP;
      return;
    }
    this.info = console.log.bind(console);
  }
};

// src/types/index.ts
var WorldEntryPoints = /* @__PURE__ */ ((WorldEntryPoints2) => {
  WorldEntryPoints2["get"] = "entity";
  WorldEntryPoints2["set"] = "set_entity";
  WorldEntryPoints2["entities"] = "entities";
  WorldEntryPoints2["execute"] = "execute";
  WorldEntryPoints2["registerSystem"] = "register_system";
  WorldEntryPoints2["registerComponent"] = "register_model";
  WorldEntryPoints2["model"] = "model";
  WorldEntryPoints2["system"] = "system";
  WorldEntryPoints2["metadataUri"] = "metadata_uri";
  WorldEntryPoints2["setMetadataUri"] = "set_metadata_uri";
  WorldEntryPoints2["registerModel"] = "register_model";
  WorldEntryPoints2["deployContract"] = "deploy_contract";
  WorldEntryPoints2["upgradeContract"] = "upgrade_contract";
  WorldEntryPoints2["uuid"] = "uuid";
  WorldEntryPoints2["emit"] = "emit";
  WorldEntryPoints2["entityIds"] = "entity_ids";
  WorldEntryPoints2["setExecutor"] = "set_executor";
  WorldEntryPoints2["executor"] = "executor";
  WorldEntryPoints2["base"] = "base";
  WorldEntryPoints2["deleteEntity"] = "delete_entity";
  WorldEntryPoints2["isOwner"] = "is_owner";
  WorldEntryPoints2["grantOwner"] = "grant_owner";
  WorldEntryPoints2["revokeOwner"] = "revoke_owner";
  WorldEntryPoints2["isWriter"] = "is_writer";
  WorldEntryPoints2["grantWriter"] = "grant_writer";
  WorldEntryPoints2["revokeWriter"] = "revoke_writer";
  return WorldEntryPoints2;
})(WorldEntryPoints || {});

// src/constants/index.ts
var LOCAL_KATANA = "http://localhost:5050";
var LOCAL_RELAY = "";
var LOCAL_TORII = "http://0.0.0.0:8080";
var KATANA_PREFUNDED_ADDRESS = "0xb3ff441a68610b30fd5e2abbf3a1548eb6ba6f3559f2862bf2dc757e5828ca";
var KATANA_PREFUNDED_PRIVATE_KEY = "0x2bbf4f9fd0bbb2e60b0316c1fe0b76cf7a4d0198bd493ced9b8df2a3a24d68a";
var KATANA_CLASS_HASH = "0x05400e90f7e0ae78bd02c77cd75527280470e2fe19c54970dd79dc37a9d3645c";
var KATANA_ETH_CONTRACT_ADDRESS = "0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7";

// src/utils/index.ts
var getContractByName = (manifest, nameSpace, name) => {
  return manifest.contracts.find((contract2) => {
    return contract2.tag === nameSpace + "-" + name;
  });
};
var parseDojoCall = (manifest, nameSpace, call) => {
  if ("contractName" in call) {
    const contract2 = getContractByName(
      manifest,
      nameSpace,
      call.contractName
    );
    return {
      contractAddress: contract2.address,
      calldata: call.calldata,
      entrypoint: call.entrypoint
    };
  } else {
    return call;
  }
};
var parseModelName = (model2) => {
  const acronyms = /* @__PURE__ */ new Set(["ERC"]);
  return model2.name.split("::").pop().split("_").map((part) => {
    if (acronyms.has(part.toUpperCase())) {
      return part.toUpperCase();
    }
    if (!isNaN(parseInt(part))) {
      return part;
    }
    return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
  }).join("");
};
var createModelTypedData = (name, model2) => {
  const typesFromSchema = (name2, schema, types) => {
    Object.entries(schema).forEach(([key, value]) => {
      let typeName = value?.constructor.name;
      switch (typeName) {
        case "Object":
          typesFromSchema(key, value, types);
          break;
        case "BigInt":
          types[name2].push({ name: key, type: "felt" });
          break;
        case "String":
          types[name2].push({ name: key, type: "shortstring" });
          break;
        case "Number":
          types[name2].push({ name: key, type: "u128" });
          break;
        case "Boolean":
          types[name2].push({ name: key, type: "bool" });
          break;
        default:
          throw new Error(`Unsupported type: ${typeName}`);
      }
    });
    return types;
  };
  return {
    types: typesFromSchema("Model", model2, {
      StarknetDomain: [
        { name: "name", type: "shortstring" },
        { name: "version", type: "shortstring" },
        { name: "chainId", type: "shortstring" },
        { name: "revision", type: "shortstring" }
      ],
      OffchainMessage: [
        { name: "model", type: "shortstring" },
        { name, type: "Model" }
      ],
      Model: []
    }),
    primaryType: "OffchainMessage",
    domain: {
      name: "Dojo",
      version: "1",
      chainId: "1",
      revision: "1"
    },
    message: {
      model: name,
      [name]: Object.fromEntries(
        Object.entries(model2).map(([k, v]) => {
          if (typeof v == "bigint") {
            return [k, "0x" + v.toString(16)];
          }
          return [k, v];
        })
      )
    }
  };
};

// src/provider/DojoProvider.ts
var DojoProvider = class extends Provider {
  provider;
  contract;
  manifest;
  logger;
  /**
   * Constructor: Initializes the DojoProvider with the given world address, manifest and URL.
   *
   * @param {string} world_address - Address of the world.
   * @param {string} [url=LOCAL_KATANA] - RPC URL (defaults to LOCAL_KATANA).
   */
  constructor(manifest, url = LOCAL_KATANA, logLevel = "none") {
    super(manifest.world.address);
    this.provider = new RpcProvider({
      nodeUrl: url
    });
    this.contract = new Contract(
      manifest.world.abi,
      this.getWorldAddress(),
      this.provider
    );
    this.manifest = manifest;
    this.logger = new ConsoleLogger({ level: logLevel });
  }
  /**
   * Retrieves a single entity's details.
   *
   * @param {string} model - The component to query.
   * @param {Array<string>} keys - The keys to query.
   * @param {number} [offset=0] - Starting offset (defaults to 0).
   * @param {number} [length=0] - Length to retrieve (defaults to 0).
   * @returns {Promise<Array<bigint>>} - A promise that resolves to an array of bigints representing the entity's details.
   */
  async entity(model2, keys, offset = 0, length = 0, layout) {
    try {
      return await this.contract.call("entity" /* get */, [
        shortString.encodeShortString(model2),
        keys.length,
        ...keys,
        offset,
        length,
        layout.length,
        layout
      ]);
    } catch (error) {
      this.logger.error("Error occured: ", error);
      throw error;
    }
  }
  /**
   * Retrieves multiple entities' details.
   *
   * @param {string} model - The component to query.
   * @param {number} index - The index to query.
   * @param {Array<string>} values - The values to query.
   * @param {number} valuesLength - The values length to query.
   * @param {Array<number>} valuesLayout - The values layout to query.
   */
  async entities(model2, index, values, valuesLength, valuesLayout) {
    try {
      return await this.contract.call("entities" /* entities */, [
        shortString.encodeShortString(model2),
        index,
        values,
        valuesLength,
        valuesLayout
      ]);
    } catch (error) {
      this.logger.error("Error occured: ", error);
      throw error;
    }
  }
  /**
   * Retrieves a models
   *
   * @param {string} name - Name of the model.
   * @returns {Promise<bigint>} - A promise that resolves to a bigint representing the model's details.
   */
  async model(name) {
    try {
      return await this.contract.call("model" /* model */, [
        shortString.encodeShortString(name)
      ]);
    } catch (error) {
      this.logger.error("Error occured: ", error);
      throw error;
    }
  }
  /**
   * Retrieves current uuid from the world contract.
   *
   * @returns {Promise<number>} - A promise that resolves to the world uuid
   * @throws {Error} - Throws an error if the call fails.
   *
   * @example
   * const uuid = await provider.uuid();
   * console.log(uuid);
   * // => 6
   *
   */
  async uuid() {
    try {
      const result = await this.provider.callContract({
        contractAddress: this.getWorldAddress(),
        entrypoint: "uuid" /* uuid */,
        calldata: []
      });
      if (result && result.length === 1) {
        return parseInt(result[0]);
      }
      throw new Error("Contract did not return expected uuid");
    } catch (error) {
      this.logger.error(`Failed to fetch uuid: ${error}`);
      throw new Error(`Failed to fetch uuid: ${error}`);
    }
  }
  /**
   * Executes a function with the given parameters.
   * This function is a wrapper around the Starknet.js Account.execute function, but is more convenient to use.
   *
   * ```ts
   * await provider.execute(signer, { contractName, entrypoint, calldata });
   * await provider.execute(signer, { contractAddress, entrypoint, calldata });
   * await provider.execute(signer, [{ contractName, entrypoint, calldata }, { contractAddress, entrypoint, calldata }]);
   * ```
   * @param {Account} account - The account to use.
   * @param {AllowArray<DojoCall | Call>} call - The call or calls
   * @param {UniversalDetails} details - https://github.com/starknet-io/starknet.js/blob/5efa196017ee8f761ae837ecac9c059da8f3e09a/src/types/account.ts#L26
   * @returns {Promise<InvokeFunctionResponse>} - A promise that resolves to the response of the function execution.
   */
  async execute(account, call, nameSpace, details = {}) {
    const dojoCalls = Array.isArray(call) ? call : [call];
    const calls = dojoCalls.map(
      (i) => parseDojoCall(this.manifest, nameSpace, i)
    );
    try {
      return await account?.execute(calls, void 0, details);
    } catch (error) {
      this.logger.error("Error occured: ", error);
      throw error;
    }
  }
  /**
   * Calls a function with the given parameters and return parsed results for a DojoCall.
   *
   * ```ts
   * let parsedResult = await provider.call({ contractName, entrypoint, calldata });
   * ```
   * @param {DojoCall | Call} call - The dojoCall or call
   * @returns {Promise<Result>} - A promise that resolves to the response of the function call.
   */
  async call(nameSpace, call) {
    if ("contractName" in call) {
      try {
        const contractInfos = getContractByName(
          this.manifest,
          nameSpace,
          call.contractName
        );
        const contract2 = new Contract(
          contractInfos.abi,
          contractInfos.address,
          this.provider
        );
        return await contract2.call(
          call.entrypoint,
          call.calldata
        );
      } catch (error) {
        this.logger.error(
          `Failed to callContract ${call.contractName}: ${error}`
        );
        throw new Error(
          `Failed to callContract ${call.contractName}: ${error}`
        );
      }
    } else {
      return this.callRaw(nameSpace, call);
    }
  }
  /**
   * Calls a function with the given parameters.
   *
   * @param {string} nameSpace - The namespace of the contract within the world
   * @param {DojoCall | Call} call - The dojoCall or call
   * @returns {Promise<CallContractResponse>} - A promise that resolves to the response of the function call.
   * @throws {Error} - Throws an error if the call fails.
   *
   * @example
   * const result = await provider.callRaw("namespace", { contractAddress, entrypoint, calldata });
   */
  async callRaw(nameSpace, call) {
    const parsedCall = parseDojoCall(this.manifest, nameSpace, call);
    try {
      return await this.provider.callContract(parsedCall);
    } catch (error) {
      this.logger.error(
        `Failed to call ${parsedCall.contractAddress}: ${error}`
      );
      throw new Error(
        `Failed to call ${parsedCall.contractAddress}: ${error}`
      );
    }
  }
};

// src/config/index.ts
function createDojoConfig({ manifest, ...config }) {
  return {
    rpcUrl: config.rpcUrl ?? LOCAL_KATANA,
    toriiUrl: config.toriiUrl ?? LOCAL_TORII,
    relayUrl: config.relayUrl ?? LOCAL_RELAY,
    masterAddress: config.masterAddress ?? KATANA_PREFUNDED_ADDRESS,
    masterPrivateKey: config.masterPrivateKey ?? KATANA_PREFUNDED_PRIVATE_KEY,
    accountClassHash: config.accountClassHash ?? KATANA_CLASS_HASH,
    feeTokenAddress: config.feeTokenAddress ?? KATANA_ETH_CONTRACT_ADDRESS,
    manifest
  };
}

// src/manifest/index.ts
import { z } from "zod";
var abiItem = z.union([
  z.object({
    type: z.literal("impl"),
    name: z.string(),
    interface_name: z.string()
  }),
  z.object({
    type: z.literal("struct"),
    name: z.string(),
    members: z.array(z.object({ name: z.string(), type: z.string() }))
  }),
  z.object({
    type: z.literal("enum"),
    name: z.string(),
    variants: z.array(z.object({ name: z.string(), type: z.string() }))
  }),
  z.object({
    type: z.literal("interface"),
    name: z.string(),
    items: z.array(
      z.object({
        type: z.literal("function"),
        name: z.string(),
        inputs: z.array(
          z.object({ name: z.string(), type: z.string() })
        ),
        outputs: z.array(z.object({ type: z.string() })),
        state_mutability: z.string()
      })
    )
  }),
  z.object({
    type: z.literal("constructor"),
    name: z.string(),
    inputs: z.array(z.object({ name: z.string(), type: z.string() }))
  }),
  z.object({
    type: z.literal("event"),
    name: z.string(),
    kind: z.literal("struct"),
    members: z.array(
      z.object({ name: z.string(), type: z.string(), kind: z.string() })
    )
  }),
  z.object({
    type: z.literal("event"),
    name: z.string(),
    kind: z.literal("enum"),
    variants: z.array(
      z.object({ name: z.string(), type: z.string(), kind: z.string() })
    )
  })
]);
var generalFields = z.object({
  class_hash: z.string(),
  name: z.string(),
  abi: z.array(abiItem)
});
var world = generalFields.extend({
  kind: z.literal("WorldContract"),
  address: z.string(),
  transaction_hash: z.string(),
  block_number: z.number(),
  seed: z.string(),
  metadata: z.object({
    rpc_url: z.string()
  })
});
var base = generalFields.extend({
  kind: z.literal("Class"),
  abi: z.literal(null)
});
var contract = generalFields.extend({
  kind: z.literal("DojoContract"),
  address: z.string(),
  reads: z.array(z.unknown()),
  writes: z.array(z.unknown()),
  computed: z.array(z.unknown())
});
var model = generalFields.extend({
  kind: z.literal("DojoModel"),
  members: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
      key: z.boolean()
    })
  )
});
var manifestSchema = z.object({
  world,
  base,
  contracts: z.array(contract),
  models: z.array(model)
});
var createManifestFromJson = (content) => {
  try {
    return manifestSchema.parse(content);
  } catch (error) {
    console.error(error);
    throw new Error("Invalid Dojo manifest.json");
  }
};
export {
  DojoProvider,
  KATANA_CLASS_HASH,
  KATANA_ETH_CONTRACT_ADDRESS,
  KATANA_PREFUNDED_ADDRESS,
  KATANA_PREFUNDED_PRIVATE_KEY,
  LOCAL_KATANA,
  LOCAL_RELAY,
  LOCAL_TORII,
  WorldEntryPoints,
  createDojoConfig,
  createManifestFromJson,
  createModelTypedData,
  getContractByName,
  parseDojoCall,
  parseModelName
};
//# sourceMappingURL=index.js.map
import { C as ConnectorIcons, a as Connector, b as ConnectorData, E as Explorer, c as ExplorerFactory } from './index-Lm9Zb_6I.js';
export { A as AccountStatus, B as Balance, n as ConnectVariables, F as ContractWriteVariables, K as DeployAccountVariables, M as MutationResult, Y as SignTypedDataVariables, a3 as StarkNameArgs, a4 as StarkNameResult, a9 as StarkProfileArgs, U as UseAccountProps, d as UseAccountResult, e as UseBalanceProps, f as UseBalanceResult, k as UseBlockNumberProps, l as UseBlockNumberResult, h as UseBlockProps, i as UseBlockResult, o as UseConnectProps, p as UseConnectResult, r as UseContractArgs, v as UseContractFactoryProps, w as UseContractFactoryResult, y as UseContractReadProps, z as UseContractReadResult, s as UseContractResult, G as UseContractWriteProps, H as UseContractWriteResult, L as UseDeployAccountProps, N as UseDeployAccountResult, P as UseDisconnectProps, Q as UseDisconnectResult, T as UseNetworkResult, W as UseProviderResult, Z as UseSignTypedDataProps, _ as UseSignTypedDataResult, a0 as UseStarkAddressProps, a1 as UseStarkAddressResult, a6 as UseWaitForTransactionProps, a7 as UseWaitForTransactionResult, u as useAccount, g as useBalance, j as useBlock, m as useBlockNumber, q as useConnect, t as useContract, x as useContractFactory, D as useContractRead, I as useContractWrite, O as useDeployAccount, R as useDisconnect, J as useExplorer, S as useInvalidateOnBlock, V as useNetwork, X as useProvider, $ as useSignTypedData, a2 as useStarkAddress, a5 as useStarkName, ab as useStarkProfile, aa as useStarkProfileResult, a8 as useWaitForTransaction } from './index-Lm9Zb_6I.js';
import { AccountInterface, constants } from 'starknet';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { Chain } from '@starknet-react/chains';
import { QueryClient } from '@tanstack/react-query';
import React from 'react';
import { ChainProviderFactory } from './providers/index.js';
export { AlchemyProviderArgs, BlastProviderArgs, InfuraProviderArgs, JsonRpcProviderArgs, LavaProviderArgs, NethermindProviderArgs, ReddioProviderArgs, alchemyProvider, blastProvider, infuraProvider, jsonRpcProvider, lavaProvider, nethermindProvider, publicProvider, reddioProvider } from './providers/index.js';
import 'eventemitter3';

/** Injected connector options. */
interface InjectedConnectorOptions {
    /** The wallet id. */
    id: string;
    /** Wallet human readable name. */
    name?: string;
    /** Wallet icons. */
    icon?: ConnectorIcons;
}
declare class InjectedConnector extends Connector {
    private _wallet?;
    private _options;
    constructor({ options }: {
        options: InjectedConnectorOptions;
    });
    get id(): string;
    get name(): string;
    get icon(): ConnectorIcons;
    available(): boolean;
    chainId(): Promise<bigint>;
    ready(): Promise<boolean>;
    connect(): Promise<ConnectorData>;
    disconnect(): Promise<void>;
    account(): Promise<AccountInterface>;
    private ensureWallet;
    private onAccountsChanged;
    private onNetworkChanged;
}

type UseInjectedConnectorsProps = {
    /** List of recommended connectors to display. */
    recommended?: Connector[];
    /** Whether to include recommended connectors in the list. */
    includeRecommended?: "always" | "onlyIfNoConnectors";
    /** How to order connectors. */
    order?: "random" | "alphabetical";
};
type UseInjectedConnectorsResult = {
    /** Connectors list. */
    connectors: Connector[];
};
declare function useInjectedConnectors({ recommended, includeRecommended, order, }: UseInjectedConnectorsProps): UseInjectedConnectorsResult;

type MockConnectorOptions = {
    /** The wallet id. */
    id: string;
    /** Wallet human readable name. */
    name: string;
    /** Wallet icons. */
    icon: ConnectorIcons;
    /** Whether the connector is available for use. */
    available?: boolean;
    /** Whether the connector should fail to connect. */
    failConnect?: boolean;
    /** Include account when switching chain. */
    unifiedSwitchAccountAndChain?: boolean;
    /** Emit change account event when switching chain. */
    emitChangeAccountOnChainSwitch?: boolean;
};
type MockConnectorAccounts = {
    goerli: AccountInterface[];
    mainnet: AccountInterface[];
};
declare class MockConnector extends Connector {
    private _accounts;
    private _accountIndex;
    private _options;
    private _connected;
    private _chainId;
    constructor({ accounts, options, }: {
        accounts: MockConnectorAccounts;
        options: MockConnectorOptions;
    });
    switchChain(chainId: bigint): void;
    switchAccount(accountIndex: number): void;
    get id(): string;
    get name(): string;
    get icon(): ConnectorIcons;
    available(): boolean;
    chainId(): Promise<bigint>;
    ready(): Promise<boolean>;
    connect(): Promise<ConnectorData>;
    disconnect(): Promise<void>;
    account(): Promise<AccountInterface>;
    private get _account();
}

declare function argent(): InjectedConnector;
declare function braavos(): InjectedConnector;
declare function injected({ id }: {
    id: string;
}): InjectedConnector;

declare class StarkCompassExplorer implements Explorer {
    name: string;
    private link;
    constructor(chain: Chain);
    block(hashOrNumber: {
        hash?: string;
        number?: number;
    }): string;
    transaction(hash: string): string;
    contract(address: string): string;
    class(hash: string): string;
}
declare const starkcompass: ExplorerFactory<StarkCompassExplorer>;

declare class StarkscanExplorer implements Explorer {
    name: string;
    private link;
    constructor(chain: Chain);
    block(hashOrNumber: {
        hash?: string;
        number?: number;
    }): string;
    transaction(hash: string): string;
    contract(address: string): string;
    class(hash: string): string;
}
declare const starkscan: ExplorerFactory<StarkscanExplorer>;

declare class ViewblockExplorer implements Explorer {
    name: string;
    private chainParam;
    private link;
    constructor(chain: Chain);
    block(hashOrNumber: {
        hash?: string;
        number?: number;
    }): string;
    transaction(hash: string): string;
    contract(address: string): string;
    class(hash: string): string;
}
declare const viewblock: ExplorerFactory<ViewblockExplorer>;

declare class VoyagerExplorer implements Explorer {
    name: string;
    private link;
    constructor(chain: Chain);
    block(hashOrNumber: {
        hash?: string;
        number?: number;
    }): string;
    transaction(hash: string): string;
    contract(address: string): string;
    class(hash: string): string;
}
declare const voyager: ExplorerFactory<VoyagerExplorer>;

/** Arguments for `StarknetProvider`. */
interface StarknetProviderProps {
    /** Chains supported by the app. */
    chains: Chain[];
    /** Provider to use. */
    provider: ChainProviderFactory;
    /** List of connectors to use. */
    connectors?: Connector[];
    /** Explorer to use. */
    explorer?: ExplorerFactory;
    /** Connect the first available connector on page load. */
    autoConnect?: boolean;
    /** React-query client to use. */
    queryClient?: QueryClient;
    /** Application. */
    children?: React.ReactNode;
}
declare function starknetChainId(chainId: bigint): constants.StarknetChainId | undefined;

declare function AccountProvider({ account, children, }: {
    account?: AccountInterface;
    children: React.ReactNode;
}): react_jsx_runtime.JSX.Element;

type StarknetConfigProps = StarknetProviderProps;
declare function StarknetConfig({ children, ...config }: StarknetConfigProps): react_jsx_runtime.JSX.Element;

declare class ConnectorAlreadyConnectedError extends Error {
    name: string;
    message: string;
}
declare class ConnectorNotConnectedError extends Error {
    name: string;
    message: string;
}
declare class ConnectorNotFoundError extends Error {
    name: string;
    message: string;
}
declare class UserRejectedRequestError extends Error {
    name: string;
    message: string;
}
declare class UserNotConnectedError extends Error {
    name: string;
    message: string;
}
declare class UnsupportedAccountInterfaceError extends Error {
    name: string;
    message: string;
}

export { ChainProviderFactory, Connector, ConnectorAlreadyConnectedError, ConnectorNotConnectedError, ConnectorNotFoundError, Explorer, ExplorerFactory, InjectedConnector, type InjectedConnectorOptions, MockConnector, type MockConnectorAccounts, type MockConnectorOptions, AccountProvider as OverrideAccount, StarkCompassExplorer, StarknetConfig, type StarknetConfigProps, StarkscanExplorer, UnsupportedAccountInterfaceError, type UseInjectedConnectorsProps, type UseInjectedConnectorsResult, UserNotConnectedError, UserRejectedRequestError, ViewblockExplorer, VoyagerExplorer, argent, braavos, injected, starkcompass, starknetChainId, starkscan, useInjectedConnectors, viewblock, voyager };

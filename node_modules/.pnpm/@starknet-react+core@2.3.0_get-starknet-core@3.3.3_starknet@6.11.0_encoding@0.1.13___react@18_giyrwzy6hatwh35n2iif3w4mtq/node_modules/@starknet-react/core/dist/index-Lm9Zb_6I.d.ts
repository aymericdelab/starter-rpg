import { AccountInterface, ContractInterface, GetBlockResponse, BlockNumber, Abi, ProviderInterface, Contract, CompiledContract, ContractFactory, Result, ArgsOrCalldata, Call, InvocationsDetails, InvokeFunctionResponse, RawArgs, BigNumberish, DeployContractResponse, TypedData, Signature, GetTransactionReceiptResponse } from 'starknet';
import EventEmitter from 'eventemitter3';
import { Chain } from '@starknet-react/chains';
import { QueryKey, UseQueryOptions, UseQueryResult as UseQueryResult$1, UseMutationOptions, UseMutationResult as UseMutationResult$1 } from '@tanstack/react-query';

/** Connector icons, as base64 encoded svg. */
type ConnectorIcons = {
    /** Dark-mode icon. */
    dark?: string;
    /** Light-mode icon. */
    light?: string;
};
/** Connector data. */
type ConnectorData = {
    /** Connector account. */
    account?: string;
    /** Connector network. */
    chainId?: bigint;
};
/** Connector events. */
interface ConnectorEvents {
    /** Emitted when account or network changes. */
    change(data: ConnectorData): void;
    /** Emitted when connection is established. */
    connect(data: ConnectorData): void;
    /** Emitted when connection is lost. */
    disconnect(): void;
}
declare abstract class Connector extends EventEmitter<ConnectorEvents> {
    /** Unique connector id. */
    abstract get id(): string;
    /** Connector name. */
    abstract get name(): string;
    /** Connector icons. */
    abstract get icon(): ConnectorIcons;
    /** Whether connector is available for use */
    abstract available(): boolean;
    /** Whether connector is already authorized */
    abstract ready(): Promise<boolean>;
    /** Connect wallet. */
    abstract connect(): Promise<ConnectorData>;
    /** Disconnect wallet. */
    abstract disconnect(): Promise<void>;
    /** Get current account. */
    abstract account(): Promise<AccountInterface>;
    /** Get current chain id. */
    abstract chainId(): Promise<bigint>;
}

interface Explorer {
    block(hashOrNumber: {
        hash?: string;
        number?: number;
    }): string;
    transaction(hash: string): string;
    contract(address: string): string;
    class(hash: string): string;
    name: string;
}
type ExplorerFactory<T extends Explorer = Explorer> = (chain: Chain) => T | null;

/** Arguments for `useAccount` hook. */
type UseAccountProps = {
    /** Function to invoke when connected. */
    onConnect?: (args: {
        address?: UseAccountResult["address"];
        connector?: UseAccountResult["connector"];
    }) => void;
    /** Function to invoke when disconnected. */
    onDisconnect?: () => void;
};
/** Account connection status. */
type AccountStatus = "connected" | "disconnected" | "connecting" | "reconnecting";
/** Value returned from `useAccount`. */
type UseAccountResult = {
    /** The connected account object. */
    account?: AccountInterface;
    /** The address of the connected account. */
    address?: string;
    /** The connected connector. */
    connector?: Connector;
    /** Connector's chain id */
    chainId?: bigint;
    /** True if connecting. */
    isConnecting?: boolean;
    /** True if reconnecting. */
    isReconnecting?: boolean;
    /** True if connected. */
    isConnected?: boolean;
    /** True if disconnected. */
    isDisconnected?: boolean;
    /** The connection status. */
    status: AccountStatus;
};
/**
 * Hook for accessing the account and its connection status.
 *
 * @remarks
 *
 * This hook is used to access the `AccountInterface` object provided by the
 * currently connected wallet.
 *
 * @example
 * This example shows how to display the wallet connection status and
 * the currently connected wallet address.
 * ```tsx
 * function Component() {
 *   const { account, address, status } = useAccount()
 *
 *   if (status === 'disconnected') return <p>Disconnected</p>
 *   return <p>Account: {address}</p>
 * }
 * ```
 */
declare function useAccount({ onConnect, onDisconnect, }?: UseAccountProps): UseAccountResult;

type UseQueryProps<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> = Pick<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, "enabled" | "refetchInterval" | "retry" | "retryDelay">;
type UseQueryResult<TData, TError> = Pick<UseQueryResult$1<TData, TError>, "data" | "error" | "status" | "isSuccess" | "isError" | "isPending" | "fetchStatus" | "isFetching" | "isLoading" | "refetch">;
type UseMutationProps<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> = Pick<UseMutationOptions<TData, TError, TVariables, TContext>, "onSuccess" | "onError" | "onMutate" | "onSettled">;
type UseMutationResult<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> = Pick<UseMutationResult$1<TData, TError, TVariables, TContext>, "data" | "error" | "isError" | "isIdle" | "isPending" | "isPaused" | "isSuccess" | "reset" | "mutate" | "mutateAsync" | "status" | "variables">;

type Balance = {
    decimals: number;
    symbol: string;
    formatted: string;
    value: bigint;
};
type UseBalanceProps = UseQueryProps<Balance, Error, Balance, ReturnType<typeof queryKey$7>> & {
    /** The contract's address. Defaults to the native currency. */
    token?: string;
    /** The address to fetch balance for. */
    address?: string;
    /** Whether to watch for changes. */
    watch?: boolean;
};
type UseBalanceResult = UseQueryResult<Balance, Error>;
declare function useBalance({ token, address, watch, enabled: enabled_, ...props }: UseBalanceProps): UseQueryResult<{
    value: bigint;
    decimals: number;
    symbol: string;
    formatted: string;
}, Error>;
declare function queryKey$7({ chain, contract, token, address, }: {
    chain: Chain;
    contract?: ContractInterface;
    token?: string;
    address?: string;
}): readonly [{
    readonly entity: "balance";
    readonly chainId: string;
    readonly contract: ContractInterface | undefined;
    readonly token: string | undefined;
    readonly address: string | undefined;
}];

/** Arguments for `useBlock`. */
type UseBlockProps = UseQueryProps<GetBlockResponse, Error, GetBlockResponse, ReturnType<typeof queryKey$6>> & {
    /** Identifier for the block to fetch. */
    blockIdentifier?: BlockNumber;
};
/** Value returned from `useBlock`. */
type UseBlockResult = UseQueryResult<GetBlockResponse, Error>;
/**
 * Hook for fetching a block.
 *
 * @remarks
 *
 * Specify which block to fetch with the `blockIdentifier` argument.
 * Control if and how often data is refreshed with `refetchInterval`.
 *
 * @example
 * This example shows how to fetch the latest block only once.
 * ```tsx
 * function Component() {
 *   const { data, isLoading, isError } = useBlock({
 *     refetchInterval: false,
 *     blockIdentifier: 'latest'
 *   })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (isError) return <span>Error...</span>
 *   return <span>Hash: {data.block_hash}</span>
 * }
 * ```
 *
 * @example
 * This example shows how to fetch the pending block every 3 seconds.
 * Use your browser network monitor to verify that the hook is refetching the
 * data.
 * ```tsx
 * function Component() {
 *   const { data, isLoading, isError } = useBlock({
 *     refetchInterval: 3000,
 *     blockIdentifier: 'pending'
 *   })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (isError) return <span>Error...</span>
 *   return <span>Hash: {data.block_hash}</span>
 * }
 * ```
 */
declare function useBlock({ blockIdentifier, ...props }?: UseBlockProps): UseBlockResult;
declare function queryKey$6({ blockIdentifier }: {
    blockIdentifier: BlockNumber;
}): readonly [{
    readonly entity: "block";
    readonly blockIdentifier: BlockNumber;
}];

/** Arguments for `useBlockNumber`. */
type UseBlockNumberProps = UseQueryProps<number, Error, number, ReturnType<typeof queryKey$5>> & {
    /** Identifier for the block to fetch. */
    blockIdentifier?: BlockNumber;
};
/** Value returned from `useBlockNumber`. */
type UseBlockNumberResult = UseQueryResult<number, Error>;
/**
 * Hook for fetching the current block number.
 *
 * @remarks
 *
 * Control if and how often data is refreshed with `refetchInterval`.
 *
 * @example
 * This example shows how to fetch the current block only once.
 * ```tsx
 * function Component() {
 *   const { data, isLoading, isError } = useBlockNumber({
 *     refetchInterval: false
 *   })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (isError) return <span>Error...</span>
 *   return <span>Block number: {data}</span>
 * }
 * ```
 *
 * @example
 * This example shows how to fetch the current block every 3 seconds.
 * Use your browser network monitor to verify that the hook is refetching the
 * data.
 * ```tsx
 * function Component() {
 *   const { data, isLoading, isError } = useBlockNumber({
 *     refetchInterval: 3000
 *   })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (isError) return <span>Error...</span>
 *   return <span>Block Number: {data}</span>
 * }
 * ```
 */
declare function useBlockNumber({ blockIdentifier, ...props }?: UseBlockNumberProps): UseBlockNumberResult;
declare function queryKey$5({ blockIdentifier }: {
    blockIdentifier: BlockNumber;
}): readonly [{
    readonly entity: "blockNumber";
    readonly blockIdentifier: BlockNumber;
}];

type ConnectVariables = {
    connector?: Connector;
};
type MutationResult$4 = UseMutationResult<void, unknown, ConnectVariables>;
type UseConnectProps = UseMutationProps<void, unknown, ConnectVariables>;
/** Value returned from `useConnect`. */
type UseConnectResult = Omit<MutationResult$4, "mutate" | "mutateAsync"> & {
    /** Current connector. */
    connector?: Connector;
    /** Connectors available for the current chain. */
    connectors: Connector[];
    /** Connector waiting approval for connection. */
    pendingConnector?: Connector;
    /** Connect to a new connector. */
    connect: (args?: ConnectVariables) => void;
    /** Connect to a new connector. */
    connectAsync: (args?: ConnectVariables) => Promise<void>;
};
/**
 * Hook for connecting to a StarkNet wallet.
 *
 * @remarks
 *
 * Use this to implement a "connect wallet" component.
 *
 * @example
 * This example shows how to connect a wallet.
 * ```tsx
 * function Component() {
 *   const { connect, connectors } = useConnect();
 *   return (
 *     <ul>
 *     {connectors.map((connector) => (
 *       <li key={connector.id}>
 *         <button onClick={() => connect({ connector })}>
 *           {connector.name}
 *         </button>
 *       </li>
 *     ))}
 *     </ul>
 *   )
 * }
 * ```
 */
declare function useConnect(props?: UseConnectProps): UseConnectResult;

/** Arguments for `useContract`. */
interface UseContractArgs {
    /** The contract abi. */
    abi?: Abi;
    /** The contract address. */
    address?: string;
    /** The provider, by default it will be the current one. */
    provider?: ProviderInterface | null;
}
/** Value returned from `useContract`. */
interface UseContractResult {
    /** The contract. */
    contract?: Contract;
}
/**
 * Hook to bind a `Contract` instance.
 *
 * @remarks
 *
 * The returned contract is a starknet.js `Contract` object.
 *
 * @example
 * This example creates a new contract from its address and abi.
 * ```tsx
 * function Component() {
 *   const { contract } = useContract({
 *     address: ethAddress,
 *     abi: compiledErc20.abi
 *   })
 *
 *   return <span>{contract.address}</span>
 * }
 * ```
 */
declare function useContract({ abi, address, provider: providedProvider, }: UseContractArgs): UseContractResult;

/** Arguments for `useContractFactory`. */
interface UseContractFactoryProps {
    /** The compiled contract. */
    compiledContract?: CompiledContract;
    /** The class hash  */
    classHash: string;
    /** The contract abi. */
    abi?: Abi;
}
/** Value returned from `useContractFactory`. */
interface UseContractFactoryResult {
    /** The contract factory. */
    contractFactory?: ContractFactory;
}
/**
 * Hook to create a `ContractFactory`.
 *
 * @remarks
 *
 * The returned contract factory is a starknet.js `ContractFactory` object.
 *
 * This hook works well with `useDeploy`.
 *
 * @example
 * This example shows how to create a contract factory.
 * ```tsx
 * function Component() {
 *   const { contractFactory } = useContractFactory({
 *     compiledContract: compiledErc20,
 *     classHash: erc20ClassHash,
 *     abi: compiledErc20.abi,
 *   })
 *
 *   return <p>Nothing to see here...</p>
 * }
 * ```
 */
declare function useContractFactory({ compiledContract, classHash, abi, }: UseContractFactoryProps): UseContractFactoryResult;

type ContractReadArgs = {
    /** The contract's function name. */
    functionName: string;
    /** Read arguments. */
    args?: ArgsOrCalldata;
    /** Block identifier used when performing call. */
    blockIdentifier?: BlockNumber;
    /** Parse arguments before passing to contract. */
    parseArgs?: boolean;
    /** Parse result after calling contract. */
    parseResult?: boolean;
};
/** Options for `useContractRead`. */
type UseContractReadProps = ContractReadArgs & UseQueryProps<Result, Error, Result, ReturnType<typeof queryKey$4>> & {
    /** The target contract's ABI. */
    abi?: Abi;
    /** The target contract's address. */
    address?: string;
    /** Refresh data at every block. */
    watch?: boolean;
};
/** Value returned from `useContractRead`. */
type UseContractReadResult = UseQueryResult<Result, Error>;
/**
 * Hook to perform a read-only contract call.
 *
 * @remarks
 *
 * The hook only performs a call if the target `abi`, `address`,
 * `functionName`, and `args` are not undefined.
 */
declare function useContractRead({ abi, address, functionName, args, blockIdentifier, parseArgs, parseResult, refetchInterval: refetchInterval_, watch, enabled: enabled_, ...props }: UseContractReadProps): UseContractReadResult;
declare function queryKey$4({ chain, contract, functionName, args, blockIdentifier, }: {
    chain?: Chain;
    contract?: Contract;
} & ContractReadArgs): readonly [{
    readonly entity: "readContract";
    readonly chainId: string | undefined;
    readonly contract: string | undefined;
    readonly functionName: string;
    readonly args: ArgsOrCalldata | undefined;
    readonly blockIdentifier: BlockNumber | undefined;
}];

/** Arguments for `useContractWrite`. */
type ContractWriteVariables = {
    /** List of smart contract calls to execute. */
    calls?: Call[];
    /** Contract ABIs for better displaying. */
    abis?: Abi[];
    /** Transaction options. */
    options?: InvocationsDetails;
};
type UseContractWriteProps = ContractWriteVariables & UseMutationProps<InvokeFunctionResponse, Error, ContractWriteVariables>;
type MutationResult$3 = UseMutationResult<InvokeFunctionResponse, Error, ContractWriteVariables>;
type UseContractWriteResult = Omit<MutationResult$3, "mutate" | "mutateAsync"> & {
    /** Execute the calls. */
    write: (args?: ContractWriteVariables) => void;
    /** Execute the calls. */
    writeAsync: (args?: ContractWriteVariables) => Promise<InvokeFunctionResponse>;
};
/**
 * Hook to perform a Starknet multicall.
 *
 * @remarks
 *
 * Multicalls are used to submit multiple transactions in a single
 * call to improve user experience.
 */
declare function useContractWrite({ calls, abis, options, ...props }: UseContractWriteProps): UseContractWriteResult;

declare function useExplorer(): Explorer;

type DeployAccountVariables = {
    /** The class hash of the contract to deploy. */
    classHash?: string;
    /** The constructor arguments. */
    constructorCalldata?: RawArgs;
    /** Address salt. */
    addressSalt?: BigNumberish;
    /** Contract address. */
    contractAddress?: string;
    /** Transaction options. */
    options?: InvocationsDetails;
};
type UseDeployAccountProps = DeployAccountVariables & UseMutationProps<DeployContractResponse, Error, DeployAccountVariables>;
type MutationResult$2 = UseMutationResult<DeployContractResponse, Error, DeployAccountVariables>;
type UseDeployAccountResult = Omit<MutationResult$2, "mutate" | "mutateAsync"> & {
    /** Deploy account. */
    deployAccount: MutationResult$2["mutate"];
    /** Deploy account. */
    deployAccountAsync: MutationResult$2["mutateAsync"];
};
/**
 * Hook for deploying a contract.
 *
 * @remarks
 *
 * This hook deploys a new contract from the currently connected account.
 */
declare function useDeployAccount({ classHash, constructorCalldata, addressSalt, contractAddress, options, ...props }: UseDeployAccountProps): UseDeployAccountResult;

type MutationResult$1 = UseMutationResult<void, unknown, void>;
type UseDisconnectProps = UseMutationProps<void, unknown, void>;
/** Value returned from `useDisconnect`. */
type UseDisconnectResult = Omit<MutationResult$1, "mutate" | "mutateAsync"> & {
    /** Disconnect wallet. */
    disconnect: MutationResult$1["mutate"];
    /** Disconnect wallet. */
    disconnectAsync: MutationResult$1["mutateAsync"];
};
declare function useDisconnect(props?: UseDisconnectProps): UseDisconnectResult;

/**
 * Invalidate the given query on every new block.
 */
declare function useInvalidateOnBlock({ enabled, queryKey, }: {
    enabled?: boolean;
    queryKey: QueryKey;
}): void;

/** Value returned from `useNetwork`. */
type UseNetworkResult = {
    /** The current chain. */
    chain: Chain;
    /** List of supported chains. */
    chains: Chain[];
};
/**
 * Hook for accessing the current connected chain.
 *
 * @remarks
 *
 * The network object contains information about the
 * network.
 *
 * @example
 * This example shows how to display the current network name.
 * ```tsx
 * function Component() {
 *   const { chain } = useNetwork()
 *
 *   return <span>{chain.name}</span>
 * }
 */
declare function useNetwork(): UseNetworkResult;

/** Value returned from `useProvider`. */
interface UseProviderResult {
    /** The current provider. */
    provider: ProviderInterface;
}
/**
 * Hook for accessing the current provider.
 *
 * @remarks
 *
 * Use this hook to access the current provider object
 * implementing starknet.js `ProviderInterface`.
 *
 * @example
 * This example shows how to access the current provider.
 * ```tsx
 * function Component() {
 *   const { provider } = useProvider()
 * }
 * ```
 */
declare function useProvider(): UseProviderResult;

type SignTypedDataVariables = Partial<TypedData>;
type MutationResult = UseMutationResult<Signature, Error, SignTypedDataVariables>;
/** Arguments for `useSignTypedData` hook. */
type UseSignTypedDataProps = Partial<TypedData> & UseMutationProps<Signature, Error, SignTypedDataVariables>;
/** Value returned by `useSignTypedData` hook. */
type UseSignTypedDataResult = Omit<MutationResult, "mutate" | "mutateAsync"> & {
    signTypedData: (args?: SignTypedDataVariables) => void;
    signTypedDataAsync: (args?: SignTypedDataVariables) => Promise<Signature>;
};
declare function useSignTypedData({ domain, types, message, primaryType, ...props }: UseSignTypedDataProps): UseSignTypedDataResult;

type UseStarkAddressProps = UseQueryProps<string, Error, string, ReturnType<typeof queryKey$3>> & {
    /** Stark name. */
    name?: string;
    /** Naming contract to use . */
    contract?: string;
};
type UseStarkAddressResult = UseQueryResult<string, Error>;
/**
 * Hook to get the address associated to a stark name.
 *
 * @remarks
 *
 * This hook fetches the address of the specified stark name
 * It defaults to the starknetID contract but a different contract can be targetted by specifying its address
 * If stark name does not have an associated address, it will return "0x0"
 *
 * @example
 * This example shows how to get the address associated to a stark name
 * ```tsx
 * function Component() {
 *   const { data, isLoading, isError } = useAddressFromStarkName({ name: 'vitalik.stark' })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (isError) return <span>Error fetching address...</span>
 *   return <span>address: {data}</span>
 * }
 * ```
 */
declare function useStarkAddress({ name, contract, enabled: enabled_, ...props }: UseStarkAddressProps): UseStarkAddressResult;
declare function queryKey$3({ name, contract, network, }: {
    name?: string;
    contract?: string;
    network?: string;
}): readonly [{
    readonly entity: "addressFromStarkName";
    readonly name: string | undefined;
    readonly contract: string | undefined;
    readonly network: string | undefined;
}];

/** Arguments for `useStarkName` hook. */
type StarkNameArgs = UseQueryProps<string, unknown, string, ReturnType<typeof queryKey$2>> & {
    /** Account address. */
    address?: string;
    /** Naming contract to use . */
    contract?: string;
};
/** Value returned by `useStarkName` hook. */
type StarkNameResult = UseQueryResult<string, unknown>;
/**
 * Hook for fetching Stark name for address.
 *
 * @remarks
 *
 * This hook fetches the stark name of the specified address.
 * It defaults to the starknet.id contract but a different contract can be
 * targetted by specifying its contract address
 * If address does not have a stark name, it will return "stark"
 *
 * @example
 * This example shows how to get the stark name of an address using the default
 * Starknet.id contract
 * ```tsx
 * function Component() {
 *   const address = '0x061b6c0a78f9edf13cea17b50719f3344533fadd470b8cb29c2b4318014f52d3'
 *   const { data, isLoading, isError } = useStarkName({ address })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (isError) return <span>Error fetching name...</span>
 *   return <span>StarkName: {data}</span>
 * }
 * ```
 *
 *  @example
 * This example shows how to get the stark name of an address specifying a
 * different contract address
 * ```tsx
 * function Component() {
 *   const address = '0x061b6c0a78f9edf13cea17b50719f3344533fadd470b8cb29c2b4318014f52d3'
 *   const { data, isLoading, isError } = useStarkName({ address, contract: '0x1234' })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (isError) return <span>Error fetching name...</span>
 *   return <span>StarkName: {data}</span>
 * }
 * ```
 */
declare function useStarkName({ address, contract, enabled: enabled_, ...props }: StarkNameArgs): StarkNameResult;
declare function queryKey$2({ address, contract, }: {
    address?: string;
    contract?: string;
}): readonly [{
    readonly entity: "starkName";
    readonly address: string | undefined;
    readonly contract: string | undefined;
}];

/** Arguments for the `useWaitForTransaction` hook. */
type UseWaitForTransactionProps = UseQueryProps<GetTransactionReceiptResponse, Error, GetTransactionReceiptResponse, ReturnType<typeof queryKey$1>> & {
    /** The transaction hash. */
    hash?: string;
    /** Refresh data at every block. */
    watch?: boolean;
};
type UseWaitForTransactionResult = UseQueryResult<GetTransactionReceiptResponse, Error>;
/**
 * Hook to fetch a single transaction receipt.
 *
 * @remarks
 *
 * This hook keeps a cache of receipts by chain and transaction hash
 * so that you can use the hook freely in your application without worrying
 * about sending duplicate network requests.
 *
 * If you need to refresh the transaction receipt data, set `watch: true` in
 * the props. The hook will periodically refresh the transaction data in the
 * background.
 *
 */
declare function useWaitForTransaction({ hash, watch, enabled: enabled_, ...props }: UseWaitForTransactionProps): UseWaitForTransactionResult;
declare function queryKey$1({ chain, hash }: {
    chain?: Chain;
    hash?: string;
}): readonly [{
    readonly entity: "transactionReceipt";
    readonly chainId: string | undefined;
    readonly hash: string | undefined;
}];

/** Arguments for `useStarkProfile` hook. */
type StarkProfileArgs = UseQueryProps<GetStarkprofileResponse, unknown, GetStarkprofileResponse, ReturnType<typeof queryKey>> & {
    /** Account address. */
    address?: string;
    /** Get Starknet ID default pfp url if no profile picture is set */
    useDefaultPfp?: boolean;
    /** Naming contract to use. */
    namingContract?: string;
    /** Identity contract to use. */
    identityContract?: string;
};
/** Value returned by `useStarkProfile` hook. */
type GetStarkprofileResponse = {
    name?: string;
    /** Metadata url of the NFT set as profile picture. */
    profile?: string;
    /** Profile picture url. */
    profilePicture?: string;
    twitter?: string;
    github?: string;
    discord?: string;
    proofOfPersonhood?: boolean;
};
type useStarkProfileResult = UseQueryResult<GetStarkprofileResponse, unknown>;
/**
 * Hook for fetching Stark profile for address.
 *
 * @remarks
 *
 * This hook fetches the stark name of the specified address, profile picture url,
 * social networks ids, and proof of personhood a user has set on its starknetid.
 * It defaults to the starknet.id naming and identity contracts but different contracts can be
 * targetted by specifying their contract addresses
 * If address does not have a stark name, it will return "stark"
 *
 * @example
 * This example shows how to get the stark profile of an address using the default
 * Starknet.id contracts
 * ```tsx
 * function Component() {
 *   const address = '0x061b6c0a78f9edf13cea17b50719f3344533fadd470b8cb29c2b4318014f52d3'
 *   const { data, isLoading, isError } = useStarkProfile({ address })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (isError) return <span>Error fetching stark profile...</span>
 *   return (
 *      <span>name: {data?.name}</span>
 *      <span>Profile picture metadata uri : {data?.profile}</span>
 *      <span>Profile picture uri : {data?.profilePicture}</span>
 *      <span>Discord id: {data?.discord}</span>
 *      <span>Twitter id: {data?.twitter}</span>
 *      <span>Github id: {data?.github}</span>
 *      <span>Proof of personhood verification: {data?.proofOfPersonhood}</span>
 *    )
 * }
 * ```
 *
 *  @example
 * This example shows how to get the stark profile of an address disabling useDefaultPfp and specifying a
 * different naming and identity contract addresses
 * ```tsx
 * function Component() {
 *   const address = '0x061b6c0a78f9edf13cea17b50719f3344533fadd470b8cb29c2b4318014f52d3'
 *   const { data, isLoading, isError } = useStarkProfile({ address, useDefaultPfp: false, namingContract: '0x1234', identityContract: '0x5678' })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (isError) return <span>Error fetching profile...</span>
 *   return (
 *      <span>name: {data?.name}</span>
 *      <span>Profile picture metadata uri : {data?.profile}</span>
 *      <span>Profile picture uri : {data?.profilePicture}</span>
 *      <span>Discord id: {data?.discord}</span>
 *      <span>Twitter id: {data?.twitter}</span>
 *      <span>Github id: {data?.github}</span>
 *      <span>Proof of personhood verification: {data?.proofOfPersonhood}</span>
 *    )
 * }
 * ```
 */
declare function useStarkProfile({ address, useDefaultPfp, namingContract, identityContract, enabled: enabled_, ...props }: StarkProfileArgs): useStarkProfileResult;
declare function queryKey({ address, namingContract, identityContract, }: {
    address?: string;
    namingContract?: string;
    identityContract?: string;
}): readonly [{
    readonly entity: "starkprofile";
    readonly address: string | undefined;
    readonly namingContract: string | undefined;
    readonly identityContract: string | undefined;
}];

export { useSignTypedData as $, type AccountStatus as A, type Balance as B, type ConnectorIcons as C, useContractRead as D, type Explorer as E, type ContractWriteVariables as F, type UseContractWriteProps as G, type UseContractWriteResult as H, useContractWrite as I, useExplorer as J, type DeployAccountVariables as K, type UseDeployAccountProps as L, type MutationResult$3 as M, type UseDeployAccountResult as N, useDeployAccount as O, type UseDisconnectProps as P, type UseDisconnectResult as Q, useDisconnect as R, useInvalidateOnBlock as S, type UseNetworkResult as T, type UseAccountProps as U, useNetwork as V, type UseProviderResult as W, useProvider as X, type SignTypedDataVariables as Y, type UseSignTypedDataProps as Z, type UseSignTypedDataResult as _, Connector as a, type UseStarkAddressProps as a0, type UseStarkAddressResult as a1, useStarkAddress as a2, type StarkNameArgs as a3, type StarkNameResult as a4, useStarkName as a5, type UseWaitForTransactionProps as a6, type UseWaitForTransactionResult as a7, useWaitForTransaction as a8, type StarkProfileArgs as a9, type useStarkProfileResult as aa, useStarkProfile as ab, type ConnectorData as b, type ExplorerFactory as c, type UseAccountResult as d, type UseBalanceProps as e, type UseBalanceResult as f, useBalance as g, type UseBlockProps as h, type UseBlockResult as i, useBlock as j, type UseBlockNumberProps as k, type UseBlockNumberResult as l, useBlockNumber as m, type ConnectVariables as n, type UseConnectProps as o, type UseConnectResult as p, useConnect as q, type UseContractArgs as r, type UseContractResult as s, useContract as t, useAccount as u, type UseContractFactoryProps as v, type UseContractFactoryResult as w, useContractFactory as x, type UseContractReadProps as y, type UseContractReadResult as z };

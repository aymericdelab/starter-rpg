// src/connectors/base.ts
import EventEmitter from "eventemitter3";
var Connector = class extends EventEmitter {
};

// src/connectors/injected.ts
import { goerli, mainnet, sepolia } from "@starknet-react/chains";

// src/errors.ts
var ConnectorAlreadyConnectedError = class extends Error {
  name = "ConnectorAlreadyConnectedError";
  message = "Connector already connected";
};
var ConnectorNotConnectedError = class extends Error {
  name = "ConnectorNotConnectedError";
  message = "Connector not connected";
};
var ConnectorNotFoundError = class extends Error {
  name = "ConnectorNotFoundError";
  message = "Connector not found";
};
var UserRejectedRequestError = class extends Error {
  name = "UserRejectedRequestError";
  message = "User rejected request";
};
var UserNotConnectedError = class extends Error {
  name = "UserNotConnectedError";
  message = "User not connected";
};
var UnsupportedAccountInterfaceError = class extends Error {
  name = "UnsupportedAccountInterfaceError";
  message = "Unsupported account interface. starknet-react v1 only supports the starknet.js v5 account interface";
};

// src/connectors/injected.ts
var WALLET_NOT_FOUND_ICON_LIGHT = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0iYmxhY2siPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+";
var WALLET_NOT_FOUND_ICON_DARK = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0id2hpdGUiPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+Cg==";
var walletIcons = {
  argentX: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA2NS4xOTUwOCA1Ny43MzU2MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNjUuMTk1MDggNTcuNzM1NjI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRkY4NzVCO30KPC9zdHlsZT4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTQwLjk4NTkyLDBIMjQuMjA4ODhjLTAuNTYsMC0xLjAxMDAxLDAuNDUxMDItMS4wMjE5NywxLjAxMjAyCgljLTAuMzM4OTksMTUuNzU1LTguNTgyMDMsMzAuNzA4OTgtMjIuNzcwMDIsNDEuMzAwOTljLTAuNDUwMDEsMC4zMzcwMS0wLjU1Mjk4LDAuOTY3OTktMC4yMjQsMS40MjNsOS44MTU5OCwxMy41NzMKCWMwLjMzNDA1LDAuNDYyMDEsMC45ODUwNSwwLjU2NTk4LDEuNDQyOTksMC4yMjY5OWM4Ljg3MTAzLTYuNTc5MDEsMTYuMDA3MDItMTQuNTE3LDIxLjE0NjA2LTIzLjMxNQoJYzUuMTM4LDguNzk4LDEyLjI3Mzk5LDE2LjczNTk5LDIxLjE0NiwyMy4zMTVjMC40NTY5NywwLjMzODk5LDEuMTA3OTcsMC4yMzUwMiwxLjQ0MTk2LTAuMjI2OTlsOS44MTYwNC0xMy41NzMKCWMwLjMyODk4LTAuNDU1MDIsMC4yMjY5OS0xLjA4Ni0wLjIyNC0xLjQyM0M1MC41ODk4NiwzMS43MjEwMSw0Mi4zNDY4OCwxNi43NjcwMyw0Mi4wMDc4OSwxLjAxMjAyCglDNDEuOTk1ODcsMC40NTEwMiw0MS41NDY4OSwwLDQwLjk4NTkyLDAiLz4KPC9zdmc+Cg==",
  braavos: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAwIiBoZWlnaHQ9IjUwMCIgdmlld0JveD0iMCAwIDUwMCA1MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0zMjMuNDQgNDEuMzg4NkMzMjQuMTk4IDQyLjY3MjggMzIzLjE5NSA0NC4yNjAzIDMyMS43MDQgNDQuMjYwM0MyOTEuNTEgNDQuMjYwMyAyNjYuOTY1IDY4LjE2NTYgMjY2LjM4OSA5Ny44NzFDMjU2LjA1IDk1Ljk0MDcgMjQ1LjMzNyA5NS43OTU2IDIzNC43NTQgOTcuNTc4N0MyMzQuMDIzIDY4LjAwOSAyMDkuNTQgNDQuMjYwMyAxNzkuNDQ1IDQ0LjI2MDNDMTc3Ljk1MyA0NC4yNjAzIDE3Ni45NDkgNDIuNjcxNiAxNzcuNzA3IDQxLjM4NjVDMTkyLjMyMyAxNi42MzMgMjE5LjQ4MyAwIDI1MC41NzMgMEMyODEuNjY0IDAgMzA4LjgyNCAxNi42MzM5IDMyMy40NCA0MS4zODg2WiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik00MTguNzU2IDIyNi44OTRDNDI2LjM3IDIyOS4yIDQzMy41ODEgMjIyLjUxNyA0MzEuMDM2IDIxNC45NzlDNDA0LjUwNyAxMzYuNDAxIDMxNi41MzUgMTA0LjM1OCAyNTAuMTU5IDEwNC4zNThDMTgzLjY3NCAxMDQuMzU4IDkzLjczOTEgMTM3LjQxOCA2OS4zMDUxIDIxNS4zMzFDNjYuOTU3NCAyMjIuODE4IDc0LjE0NjUgMjI5LjI3NSA4MS42NDc5IDIyNi45NzdMMjQ0LjI1IDE3Ny4xNTFDMjQ3LjU2OSAxNzYuMTM0IDI1MS4xMTYgMTc2LjEyOCAyNTQuNDM5IDE3Ny4xMzVMNDE4Ljc1NiAyMjYuODk0WiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik02OS43MTY1IDIzOS40MjZMMjQ0LjM3IDE4Ni40NTZDMjQ3LjY2OSAxODUuNDU2IDI1MS4xOTEgMTg1LjQ1MyAyNTQuNDkyIDE4Ni40NDhMNDMwLjIzMiAyMzkuNDUyQzQ0NC43NiAyNDMuODMzIDQ1NC43MDEgMjU3LjIxNiA0NTQuNzAxIDI3Mi4zOVY0MzAuNDgxQzQ1NC4wMjggNDY5LjA3IDQxOS4zNjIgNTAwIDM4MC43ODYgNTAwSDMxNi43MTJDMzEwLjM3OSA1MDAgMzA1LjI1IDQ5NC44NzcgMzA1LjI1IDQ4OC41NDNWNDMzLjExNUMzMDUuMjUgNDExLjI4OSAzMTguMTY3IDM5MS41MzUgMzM4LjE1NSAzODIuNzkyQzM2NC45NDkgMzcxLjA3MSAzOTYuNjQ2IDM1NS4yMTggNDAyLjYwOCAzMjMuNDA2QzQwNC41MzIgMzEzLjEzOCAzOTcuODM3IDMwMy4yMzQgMzg3LjU5NSAzMDEuMTk4QzM2MS42OTkgMjk2LjA1MSAzMzIuOTg5IDI5OC4wMzkgMzA4LjcxMSAzMDguODk4QzI4MS4xNSAzMjEuMjI1IDI3My45NCAzNDEuNzMxIDI3MS4yNzEgMzY5LjI3TDI2OC4wMzYgMzk4LjkzOEMyNjcuMDQ3IDQwOC4wMDUgMjU4LjU0NiA0MTQuOTUyIDI0OS40MjkgNDE0Ljk1MkMyMzkuOTk4IDQxNC45NTIgMjMyLjkyNiA0MDcuNzY5IDIzMS45MDMgMzk4LjM4OEwyMjguNzI4IDM2OS4yN0MyMjYuNDQyIDM0NS42ODEgMjIyLjI5OCAzMjIuNzY3IDE5Ny45MTIgMzExLjg2QzE3MC4wOTUgMjk5LjQxOSAxNDIuMTQxIDI5NS4yODcgMTEyLjQwNCAzMDEuMTk4QzEwMi4xNjIgMzAzLjIzNCA5NS40NjcgMzEzLjEzOCA5Ny4zOTEzIDMyMy40MDZDMTAzLjQwNSAzNTUuNDk1IDEzNC44NTQgMzcwLjk4NSAxNjEuODQ0IDM4Mi43OTJDMTgxLjgzMyAzOTEuNTM1IDE5NC43NSA0MTEuMjg5IDE5NC43NSA0MzMuMTE1VjQ4OC41MzNDMTk0Ljc1IDQ5NC44NjcgMTg5LjYyMiA1MDAgMTgzLjI4OSA1MDBIMTE5LjIxNEM4MC42Mzc0IDUwMCA0NS45NzE2IDQ2OS4wNyA0NS4yOTc5IDQzMC40ODFWMjcyLjM0OUM0NS4yOTc5IDI1Ny4xOTQgNTUuMjE0MiAyNDMuODI0IDY5LjcxNjUgMjM5LjQyNloiIGZpbGw9InVybCgjcGFpbnQyX2xpbmVhcl8yMzI0XzYxODY5KSIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDJfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4="
};
var InjectedConnector = class extends Connector {
  _wallet;
  _options;
  constructor({ options }) {
    super();
    this._options = options;
  }
  get id() {
    return this._options.id;
  }
  get name() {
    return this._options.name ?? this._wallet?.name ?? this._options.id;
  }
  get icon() {
    let defaultIcon = {
      dark: this._wallet?.icon || walletIcons[this.id] || WALLET_NOT_FOUND_ICON_DARK,
      light: this._wallet?.icon || walletIcons[this.id] || WALLET_NOT_FOUND_ICON_LIGHT
    };
    return this._options.icon ?? defaultIcon;
  }
  available() {
    this.ensureWallet();
    return this._wallet !== void 0;
  }
  async chainId() {
    this.ensureWallet();
    if (!this._wallet) {
      throw new ConnectorNotConnectedError();
    }
    const chainIdHex = await this._wallet.provider.getChainId();
    const chainId = BigInt(chainIdHex);
    return chainId;
  }
  async ready() {
    this.ensureWallet();
    if (!this._wallet)
      return false;
    return await this._wallet.isPreauthorized();
  }
  async connect() {
    this.ensureWallet();
    if (!this._wallet) {
      throw new ConnectorNotFoundError();
    }
    let accounts;
    try {
      accounts = await this._wallet.enable({ starknetVersion: "v5" });
    } catch {
      throw new UserRejectedRequestError();
    }
    if (!this._wallet.isConnected || !accounts) {
      throw new UserRejectedRequestError();
    }
    this._wallet.on(
      "accountsChanged",
      async (accounts2) => {
        await this.onAccountsChanged(accounts2);
      }
    );
    this._wallet.on("networkChanged", (network) => {
      this.onNetworkChanged(network);
    });
    await this.onAccountsChanged(accounts);
    const account = this._wallet.account.address;
    const chainId = await this.chainId();
    this.emit("connect", { account, chainId });
    return {
      account,
      chainId
    };
  }
  async disconnect() {
    this.ensureWallet();
    if (!this.available()) {
      throw new ConnectorNotFoundError();
    }
    if (!this._wallet?.isConnected) {
      throw new UserNotConnectedError();
    }
    this.emit("disconnect");
  }
  async account() {
    this.ensureWallet();
    if (!this._wallet || !this._wallet.account) {
      throw new ConnectorNotConnectedError();
    }
    return this._wallet.account;
  }
  ensureWallet() {
    const installed = getAvailableWallets(globalThis);
    const wallet = installed.filter((w) => w.id === this._options.id)[0];
    if (wallet) {
      this._wallet = wallet;
    }
  }
  async onAccountsChanged(accounts) {
    let account;
    if (typeof accounts === "string") {
      account = accounts;
    } else {
      account = accounts[0];
    }
    if (account) {
      const chainId = await this.chainId();
      this.emit("change", { account, chainId });
    } else {
      this.emit("disconnect");
    }
  }
  onNetworkChanged(network) {
    switch (network) {
      case "SN_MAIN":
        this.emit("change", { chainId: mainnet.id });
        break;
      case "SN_GOERLI":
        this.emit("change", { chainId: goerli.id });
        break;
      case "SN_SEPOLIA":
        this.emit("change", { chainId: sepolia.id });
        break;
      case "mainnet-alpha":
        this.emit("change", { chainId: mainnet.id });
        break;
      case "goerli-alpha":
        this.emit("change", { chainId: goerli.id });
        break;
      case "sepolia-alpha":
        this.emit("change", { chainId: sepolia.id });
        break;
      default:
        this.emit("change", {});
        break;
    }
  }
};
function getAvailableWallets(obj) {
  return Object.values(
    Object.getOwnPropertyNames(obj).reduce((wallets, key) => {
      if (key.startsWith("starknet")) {
        const wallet = obj[key];
        if (isWalletObject(wallet) && !wallets[wallet.id]) {
          wallets[wallet.id] = wallet;
        }
      }
      return wallets;
    }, {})
  );
}
function isWalletObject(wallet) {
  try {
    return wallet && [
      // wallet's must have methods/members, see IStarknetWindowObject
      "request",
      "isConnected",
      "provider",
      "enable",
      "isPreauthorized",
      "on",
      "off",
      "version",
      "id",
      "name",
      "icon"
    ].every((key) => key in wallet);
  } catch (err) {
  }
  return false;
}

// src/connectors/discovery.ts
import { useCallback, useEffect, useMemo, useState } from "react";

// src/connectors/helpers.ts
function argent() {
  return new InjectedConnector({
    options: {
      id: "argentX",
      name: "Argent"
    }
  });
}
function braavos() {
  return new InjectedConnector({
    options: {
      id: "braavos",
      name: "Braavos"
    }
  });
}
function injected({ id }) {
  return new InjectedConnector({
    options: {
      id
    }
  });
}

// src/connectors/discovery.ts
function useInjectedConnectors({
  recommended,
  includeRecommended = "always",
  order = "alphabetical"
}) {
  const [injectedConnectors, setInjectedConnectors] = useState([]);
  const refreshConnectors = useCallback(() => {
    const wallets = scanObjectForWallets(window);
    const connectors2 = wallets.map((wallet) => injected({ id: wallet.id }));
    setInjectedConnectors(connectors2);
  }, [setInjectedConnectors]);
  useEffect(() => {
    refreshConnectors();
  }, [refreshConnectors]);
  const connectors = useMemo(() => {
    return mergeConnectors(injectedConnectors, recommended ?? [], {
      includeRecommended,
      order
    });
  }, [injectedConnectors, recommended, includeRecommended, order]);
  return { connectors };
}
function mergeConnectors(injected2, recommended, {
  includeRecommended,
  order
}) {
  const injectedIds = new Set(injected2.map((connector) => connector.id));
  const allConnectors = injected2;
  const shouldAddRecommended = includeRecommended === "always" || includeRecommended === "onlyIfNoConnectors" && injected2.length === 0;
  if (shouldAddRecommended) {
    allConnectors.push(
      ...recommended.filter((connector) => !injectedIds.has(connector.id))
    );
  }
  if (order === "random") {
    return shuffle(allConnectors);
  }
  return allConnectors.sort((a, b) => a.id.localeCompare(b.id));
}
function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function scanObjectForWallets(obj) {
  return Object.values(
    Object.getOwnPropertyNames(obj).reduce((wallets, key) => {
      if (key.startsWith("starknet")) {
        const wallet = obj[key];
        if (isWalletObject2(wallet) && !wallets[wallet.id]) {
          wallets[wallet.id] = wallet;
        }
      }
      return wallets;
    }, {})
  );
}
function isWalletObject2(wallet) {
  try {
    return wallet && [
      // wallet's must have methods/members, see IStarknetWindowObject
      "request",
      "isConnected",
      "provider",
      "enable",
      "isPreauthorized",
      "on",
      "off",
      "version",
      "id",
      "name",
      "icon"
    ].every((key) => key in wallet);
  } catch (err) {
  }
  return false;
}

// src/connectors/mock.ts
import { goerli as goerli2, mainnet as mainnet2 } from "@starknet-react/chains";
var MockConnector = class extends Connector {
  _accounts;
  _accountIndex = 0;
  _options;
  _connected = false;
  _chainId = goerli2.id;
  constructor({
    accounts,
    options
  }) {
    super();
    if (accounts.mainnet.length === 0 || accounts.goerli.length === 0) {
      throw new Error("MockConnector: accounts must not be empty");
    }
    this._accounts = accounts;
    this._options = options;
  }
  switchChain(chainId) {
    this._chainId = chainId;
    this._accountIndex = 0;
    let account;
    if (this._options.unifiedSwitchAccountAndChain) {
      account = this._account.address;
    }
    this.emit("change", { chainId, account });
    if (this._options.emitChangeAccountOnChainSwitch ?? true) {
      this.switchAccount(this._accountIndex);
    }
  }
  switchAccount(accountIndex) {
    this._accountIndex = accountIndex;
    this.emit("change", { account: this._account.address });
  }
  get id() {
    return this._options.id;
  }
  get name() {
    return this._options.name;
  }
  get icon() {
    return this._options.icon;
  }
  available() {
    return this._options.available ?? true;
  }
  async chainId() {
    return this._chainId;
  }
  async ready() {
    return this._connected;
  }
  async connect() {
    if (this._options.failConnect) {
      throw new UserRejectedRequestError();
    }
    this._connected = true;
    return {
      account: this._account.address,
      chainId: this._chainId
    };
  }
  async disconnect() {
    this._connected = false;
    this.emit("disconnect");
  }
  async account() {
    if (!this.available()) {
      throw new ConnectorNotFoundError();
    }
    if (!this._connected) {
      throw new ConnectorNotConnectedError();
    }
    return this._account;
  }
  get _account() {
    let account;
    if (this._chainId === mainnet2.id) {
      account = this._accounts.mainnet[this._accountIndex];
    } else {
      account = this._accounts.goerli[this._accountIndex];
    }
    if (!account) {
      throw new ConnectorNotConnectedError();
    }
    return account;
  }
};

// src/context/starknet.tsx
import { goerli as goerli3, mainnet as mainnet3, sepolia as sepolia2 } from "@starknet-react/chains";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import {
  createContext,
  useCallback as useCallback2,
  useContext as useContext2,
  useEffect as useEffect2,
  useRef,
  useState as useState2
} from "react";
import { constants } from "starknet";

// src/context/account.tsx
import React, { useContext } from "react";
import { jsx } from "react/jsx-runtime";
var AccountContext = React.createContext(
  void 0
);
function useStarknetAccount() {
  const account = useContext(AccountContext);
  return { account };
}
function AccountProvider({
  account,
  children
}) {
  return /* @__PURE__ */ jsx(AccountContext.Provider, { value: account, children });
}

// src/context/starknet.tsx
import { jsx as jsx2 } from "react/jsx-runtime";
var StarknetContext = createContext(void 0);
function useStarknet() {
  const state = useContext2(StarknetContext);
  if (!state) {
    throw new Error(
      "useStarknet must be used within a StarknetProvider or StarknetConfig"
    );
  }
  return state;
}
function useStarknetManager({
  chains,
  provider,
  explorer,
  connectors = [],
  autoConnect = false
}) {
  const initialChain = chains[0];
  if (initialChain === void 0) {
    throw new Error("Must provide at least one chain.");
  }
  const { chain: defaultChain, provider: defaultProvider } = providerForChain(
    initialChain,
    provider
  );
  const connectorRef = useRef();
  const [state, setState] = useState2({
    currentChain: defaultChain,
    currentProvider: defaultProvider,
    connectors
  });
  const updateChainAndProvider = useCallback2(
    ({ chainId }) => {
      if (!chainId)
        return;
      for (const chain of chains) {
        if (chain.id === chainId) {
          const { chain: newChain, provider: newProvider } = providerForChain(
            chain,
            provider
          );
          setState((state2) => ({
            ...state2,
            currentChain: newChain,
            currentProvider: newProvider
          }));
          return;
        }
      }
    },
    [setState, chains]
  );
  const handleConnectorChange = useCallback2(
    async ({ chainId, account }) => {
      if (chainId) {
        updateChainAndProvider({ chainId });
      }
      if (account && connectorRef.current) {
        const account2 = await connectorRef.current.account();
        setState((state2) => ({
          ...state2,
          currentAccount: account2
        }));
      }
    },
    [updateChainAndProvider, setState, connectorRef]
  );
  const connect = useCallback2(
    async ({ connector }) => {
      if (!connector) {
        throw new Error("Must provide a connector.");
      }
      const needsListenerSetup = connectorRef.current?.id !== connector.id;
      if (needsListenerSetup) {
        connectorRef.current?.off("change", handleConnectorChange);
      }
      try {
        const { chainId } = await connector.connect();
        const account = await connector.account();
        if (account.address !== state.currentAccount?.address) {
          connectorRef.current = connector;
          setState((state2) => ({
            ...state2,
            currentAccount: account
          }));
        }
        if (autoConnect) {
          localStorage.setItem("lastUsedConnector", connector.id);
        }
        if (needsListenerSetup) {
          connector.on("change", handleConnectorChange);
        }
        updateChainAndProvider({ chainId });
      } catch (err) {
        setState((state2) => ({
          ...state2,
          error: new ConnectorNotFoundError()
        }));
        throw err;
      }
    },
    [
      autoConnect,
      setState,
      connectorRef,
      state.currentAccount,
      handleConnectorChange,
      updateChainAndProvider
    ]
  );
  const disconnect = useCallback2(async () => {
    setState((state2) => ({
      ...state2,
      currentAccount: void 0,
      currentProvider: defaultProvider,
      currentChain: defaultChain
    }));
    if (autoConnect) {
      localStorage.removeItem("lastUsedConnector");
    }
    if (!connectorRef.current)
      return;
    connectorRef.current.off("change", handleConnectorChange);
    try {
      await connectorRef.current.disconnect();
    } catch {
    }
    connectorRef.current = void 0;
  }, [
    autoConnect,
    setState,
    connectorRef,
    handleConnectorChange,
    defaultProvider,
    defaultChain
  ]);
  useEffect2(() => {
    async function tryAutoConnect(connectors2) {
      const lastConnectedConnectorId = localStorage.getItem("lastUsedConnector");
      if (lastConnectedConnectorId === null) {
        return;
      }
      const lastConnectedConnector = connectors2.find(
        (connector) => connector.id === lastConnectedConnectorId
      );
      if (lastConnectedConnector === void 0) {
        return;
      }
      try {
        if (!await lastConnectedConnector.ready()) {
          return;
        }
        connect({ connector: lastConnectedConnector });
      } catch {
      }
    }
    if (autoConnect && !connectorRef.current) {
      tryAutoConnect(connectors);
    }
  }, []);
  return {
    account: state.currentAccount,
    provider: state.currentProvider,
    chain: state.currentChain,
    connector: connectorRef.current,
    explorer,
    connect,
    disconnect,
    connectors,
    chains
  };
}
function StarknetProvider({
  chains,
  provider,
  connectors,
  explorer,
  autoConnect,
  queryClient,
  children
}) {
  const { account, ...state } = useStarknetManager({
    chains,
    provider,
    explorer,
    connectors,
    autoConnect
  });
  return /* @__PURE__ */ jsx2(QueryClientProvider, { client: queryClient ?? new QueryClient(), children: /* @__PURE__ */ jsx2(StarknetContext.Provider, { value: state, children: /* @__PURE__ */ jsx2(AccountProvider, { account, children }) }) });
}
function providerForChain(chain, factory) {
  const provider = factory(chain);
  if (provider) {
    return { chain, provider };
  }
  throw new Error(`No provider found for chain ${chain.name}`);
}
function starknetChainId(chainId) {
  switch (chainId) {
    case mainnet3.id:
      return constants.StarknetChainId.SN_MAIN;
    case goerli3.id:
      return constants.StarknetChainId.SN_GOERLI;
    case sepolia2.id:
      return constants.StarknetChainId.SN_SEPOLIA;
    default:
      return void 0;
  }
}

// src/context/index.tsx
import { jsx as jsx3 } from "react/jsx-runtime";
function StarknetConfig({ children, ...config }) {
  return /* @__PURE__ */ jsx3(StarknetProvider, { ...config, children });
}

// src/explorers/starkCompass.ts
var StarkCompassExplorer = class {
  name = "Stark Compass";
  link;
  constructor(chain) {
    this.link = chain.explorers?.["starkCompass"]?.toString() ?? "";
  }
  block(hashOrNumber) {
    return `${this.link}/blocks/${hashOrNumber.hash ?? hashOrNumber.number}`;
  }
  transaction(hash2) {
    return `${this.link}/transactions/${hash2}`;
  }
  contract(address) {
    return `${this.link}/contracts/${address}`;
  }
  class(hash2) {
    return `${this.link}/classes/${hash2}`;
  }
};
var starkcompass = (chain) => {
  return new StarkCompassExplorer(chain);
};

// src/explorers/starkscan.ts
var StarkscanExplorer = class {
  name = "Starkscan";
  link;
  constructor(chain) {
    this.link = chain.explorers?.["starkscan"]?.toString() ?? "";
  }
  block(hashOrNumber) {
    return `${this.link}/block/${hashOrNumber.hash ?? hashOrNumber.number}`;
  }
  transaction(hash2) {
    return `${this.link}/tx/${hash2}`;
  }
  contract(address) {
    return `${this.link}/contract/${address}`;
  }
  class(hash2) {
    return `${this.link}/class/${hash2}`;
  }
};
var starkscan = (chain) => {
  return new StarkscanExplorer(chain);
};

// src/explorers/viewblock.ts
import { goerli as goerli4 } from "@starknet-react/chains";
var ViewblockExplorer = class {
  name = "Viewblock";
  chainParam;
  link;
  constructor(chain) {
    this.link = chain.explorers?.["viewblock"]?.toString() ?? "";
    this.chainParam = chain.id === goerli4.id ? "?network=goerli" : "";
  }
  block(hashOrNumber) {
    if (hashOrNumber.hash && hashOrNumber.number === void 0) {
      throw new Error(
        `The viewblock explorer doesnt support hashes for blocks. Please provide a hash.`
      );
    }
    return `${this.link}/block/${hashOrNumber.number}${this.chainParam}`;
  }
  transaction(hash2) {
    return `${this.link}/tx/${hash2}${this.chainParam}`;
  }
  contract(address) {
    return `${this.link}/contract/${address}${this.chainParam}`;
  }
  class(hash2) {
    return `${this.link}/class/${hash2}${this.chainParam}`;
  }
};
var viewblock = (chain) => {
  return new ViewblockExplorer(chain);
};

// src/explorers/voyager.ts
var VoyagerExplorer = class {
  name = "Voyager";
  link;
  constructor(chain) {
    this.link = chain.explorers?.["voyager"]?.toString() ?? "";
  }
  block(hashOrNumber) {
    if (hashOrNumber.number !== void 0 && hashOrNumber.hash === void 0) {
      throw new Error(
        "The voyager explorer doesn't support numbers for blocks. Please provide a hash."
      );
    }
    return `${this.link}/block/${hashOrNumber.hash}`;
  }
  transaction(hash2) {
    return `${this.link}/tx/${hash2}`;
  }
  contract(address) {
    return `${this.link}/contract/${address}`;
  }
  class(hash2) {
    return `${this.link}/class/${hash2}`;
  }
};
var voyager = (chain) => {
  return new VoyagerExplorer(chain);
};

// src/providers/jsonrpc.ts
import { RpcProvider } from "starknet";
function jsonRpcProvider({
  rpc
}) {
  return function(chain) {
    const config = rpc(chain);
    if (!config)
      return null;
    const chainId = starknetChainId(chain.id);
    const provider = new RpcProvider({ ...config, chainId });
    return provider;
  };
}

// src/providers/public.ts
function publicProvider() {
  return jsonRpcProvider({
    rpc: (chain) => {
      const rpcs = chain.rpcUrls.public.http;
      const nodeUrl = rpcs[Math.floor(Math.random() * rpcs.length)];
      if (!nodeUrl)
        return null;
      return { nodeUrl };
    }
  });
}

// src/providers/alchemy.ts
function alchemyProvider({ apiKey }) {
  return jsonRpcProvider({
    rpc: (chain) => {
      const baseHttpUrl = chain.rpcUrls["alchemy"]?.http[0];
      if (!baseHttpUrl)
        return null;
      const nodeUrl = `${baseHttpUrl}/${apiKey}`;
      return { nodeUrl };
    }
  });
}

// src/providers/blast.ts
function blastProvider({ apiKey }) {
  return jsonRpcProvider({
    rpc: (chain) => {
      const baseHttpUrl = chain.rpcUrls["blast"]?.http[0];
      if (!baseHttpUrl)
        return null;
      const nodeUrl = `${baseHttpUrl}/${apiKey}`;
      return { nodeUrl };
    }
  });
}

// src/providers/infura.ts
function infuraProvider({ apiKey }) {
  return jsonRpcProvider({
    rpc: (chain) => {
      const baseHttpUrl = chain.rpcUrls["infura"]?.http[0];
      if (!baseHttpUrl)
        return null;
      const nodeUrl = `${baseHttpUrl}/${apiKey}`;
      return { nodeUrl };
    }
  });
}

// src/providers/lava.ts
function lavaProvider({ apiKey }) {
  return jsonRpcProvider({
    rpc: (chain) => {
      const baseHttpUrl = chain.rpcUrls["lava"]?.http[0];
      if (!baseHttpUrl)
        return null;
      const nodeUrl = `${baseHttpUrl}/${apiKey}`;
      return { nodeUrl };
    }
  });
}

// src/providers/nethermind.ts
function nethermindProvider({ apiKey }) {
  return jsonRpcProvider({
    rpc: (chain) => {
      const baseHttpUrl = chain.rpcUrls["nethermind"]?.http[0];
      if (!baseHttpUrl)
        return null;
      const nodeUrl = `${baseHttpUrl}/?apikey=${apiKey}`;
      return { nodeUrl };
    }
  });
}

// src/providers/reddio.ts
function reddioProvider({ apiKey }) {
  return jsonRpcProvider({
    rpc: (chain) => {
      const baseHttpUrl = chain.rpcUrls["reddio"]?.http[0];
      if (!baseHttpUrl)
        return null;
      const nodeUrl = `${baseHttpUrl}/${apiKey}`;
      return { nodeUrl };
    }
  });
}

// src/hooks/useAccount.ts
import { useCallback as useCallback4, useEffect as useEffect3, useState as useState3 } from "react";

// src/hooks/useConnect.ts
import { useCallback as useCallback3 } from "react";

// src/query.ts
import {
  useMutation as useMutation_,
  useQuery as useQuery_
} from "@tanstack/react-query";
function useQuery(args) {
  const base = useQuery_(args);
  return {
    data: base.data,
    error: base.error,
    status: base.status,
    isSuccess: base.isSuccess,
    isError: base.isError,
    isPending: base.isPending,
    fetchStatus: base.fetchStatus,
    isFetching: base.isFetching,
    isLoading: base.isLoading,
    refetch: base.refetch
  };
}
function useMutation(args) {
  const base = useMutation_(args);
  return {
    data: base.data,
    error: base.error,
    reset: base.reset,
    isError: base.isError,
    isIdle: base.isIdle,
    isPending: base.isPending,
    isSuccess: base.isSuccess,
    isPaused: base.isPaused,
    mutate: base.mutate,
    mutateAsync: base.mutateAsync,
    status: base.status,
    variables: base.variables
  };
}

// src/hooks/useConnect.ts
function useConnect(props = {}) {
  const { connector, connectors, connect: connect_, chain } = useStarknet();
  const { mutate, mutateAsync, variables, ...result } = useMutation({
    mutationKey: [{ entity: "connect", chainId: chain.name }],
    mutationFn: connect_,
    ...props
  });
  const connect = useCallback3(
    (args) => mutate(args ?? { connector }),
    [mutate, connector]
  );
  const connectAsync = useCallback3(
    (args) => mutateAsync(args ?? { connector }),
    [mutateAsync, connector]
  );
  return {
    connector,
    connectors,
    pendingConnector: variables?.connector,
    connect,
    connectAsync,
    variables,
    ...result
  };
}

// src/hooks/useAccount.ts
function useAccount({
  onConnect,
  onDisconnect
} = {}) {
  const { account: connectedAccount } = useStarknetAccount();
  const { connectors } = useConnect();
  const [state, setState] = useState3({
    status: "disconnected"
  });
  const refreshState = useCallback4(async () => {
    if (!connectedAccount) {
      if (!state.isDisconnected && onDisconnect !== void 0) {
        onDisconnect();
      }
      return setState({
        status: "disconnected",
        isDisconnected: true,
        isConnected: false,
        isConnecting: false,
        isReconnecting: false
      });
    }
    for (const connector of connectors) {
      if (!connector.available())
        continue;
      let connAccount;
      try {
        connAccount = await connector.account();
      } catch {
      }
      if (connAccount && connAccount?.address === connectedAccount.address) {
        if (state.isDisconnected && onConnect !== void 0) {
          onConnect({ address: connectedAccount.address, connector });
        }
        return setState({
          connector,
          chainId: await connector.chainId(),
          account: connectedAccount,
          address: connectedAccount.address,
          status: "connected",
          isConnected: true,
          isConnecting: false,
          isDisconnected: false,
          isReconnecting: false
        });
      }
    }
    setState({
      connector: void 0,
      chainId: void 0,
      account: connectedAccount,
      address: connectedAccount.address,
      status: "connected",
      isConnected: true,
      isConnecting: false,
      isDisconnected: false,
      isReconnecting: false
    });
  }, [
    setState,
    connectedAccount,
    connectors,
    onConnect,
    onDisconnect,
    state.isDisconnected
  ]);
  useEffect3(() => {
    refreshState();
  }, [refreshState]);
  return state;
}

// src/hooks/useBalance.ts
import { useMemo as useMemo3 } from "react";
import {
  CallData,
  num,
  shortString,
  uint256
} from "starknet";
import { z } from "zod";

// src/hooks/useContract.ts
import { useMemo as useMemo2 } from "react";
import { Contract } from "starknet";
function useContract({
  abi,
  address,
  provider: providedProvider
}) {
  const { provider: currentProvider } = useStarknet();
  const contract = useMemo2(() => {
    const provider = providedProvider ? providedProvider : currentProvider;
    if (abi && address && provider) {
      return new Contract(abi, address, provider);
    }
    return void 0;
  }, [abi, address, providedProvider, currentProvider]);
  return { contract };
}

// src/hooks/useInvalidateOnBlock.ts
import { useQueryClient } from "@tanstack/react-query";
import { useEffect as useEffect4, useState as useState4 } from "react";

// src/hooks/useBlockNumber.ts
import { BlockTag } from "starknet";
function useBlockNumber({
  blockIdentifier = BlockTag.latest,
  ...props
} = {}) {
  const { provider } = useStarknet();
  return useQuery({
    queryKey: queryKey({ blockIdentifier }),
    queryFn: queryFn({ provider, blockIdentifier }),
    ...props
  });
}
function queryKey({ blockIdentifier }) {
  return [{ entity: "blockNumber", blockIdentifier }];
}
function queryFn({
  provider,
  blockIdentifier
}) {
  return async function() {
    const block = await provider.getBlock(blockIdentifier);
    return block.block_number;
  };
}

// src/hooks/useInvalidateOnBlock.ts
function useInvalidateOnBlock({
  enabled = true,
  queryKey: queryKey9
}) {
  const queryClient = useQueryClient();
  const [prevBlockNumber, setPrevBlockNumber] = useState4();
  const { data: blockNumber } = useBlockNumber({
    enabled
  });
  useEffect4(() => {
    if (!prevBlockNumber) {
      return setPrevBlockNumber(blockNumber);
    }
    if (blockNumber !== prevBlockNumber) {
      queryClient.invalidateQueries({ queryKey: queryKey9 }, { cancelRefetch: false });
      return setPrevBlockNumber(blockNumber);
    }
  }, [blockNumber, prevBlockNumber]);
}

// src/hooks/useNetwork.ts
function useNetwork() {
  const { chain, chains } = useStarknet();
  return { chain, chains };
}

// src/hooks/useBalance.ts
function useBalance({
  token,
  address,
  watch = false,
  enabled: enabled_ = true,
  ...props
}) {
  const { chain } = useNetwork();
  const { contract } = useContract({
    abi: balanceABIFragment,
    address: token ?? chain.nativeCurrency.address
  });
  const queryKey_ = useMemo3(
    () => queryKey2({ chain, contract, token, address }),
    [chain, contract, token, address]
  );
  const enabled = useMemo3(
    () => Boolean(enabled_ && contract && address),
    [enabled_, contract, address]
  );
  useInvalidateOnBlock({
    enabled: Boolean(enabled && watch),
    queryKey: queryKey_
  });
  return useQuery({
    queryKey: queryKey_,
    queryFn: queryFn2({ chain, contract, token, address }),
    ...props
  });
}
function queryKey2({
  chain,
  contract,
  token,
  address
}) {
  return [
    {
      entity: "balance",
      chainId: chain?.name,
      contract,
      token,
      address
    }
  ];
}
function queryFn2({
  chain,
  token,
  address,
  contract
}) {
  return async function() {
    if (!address)
      throw new Error("address is required");
    if (!contract)
      throw new Error("contract is required");
    let symbolPromise = Promise.resolve(chain.nativeCurrency.symbol);
    if (token) {
      symbolPromise = contract.call("symbol", []).then((result) => {
        const s = symbolSchema.parse(result).symbol;
        return shortString.decodeShortString(num.toHex(s));
      });
    }
    let decimalsPromise = Promise.resolve(chain.nativeCurrency.decimals);
    if (token) {
      decimalsPromise = contract.call("decimals", []).then((result) => {
        return Number(decimalsSchema.parse(result).decimals);
      });
    }
    const balanceOfPromise = contract.call("balanceOf", CallData.compile({ address })).then((result) => {
      return uint256.uint256ToBN(balanceSchema.parse(result).balance);
    });
    const [balanceOf, decimals, symbol] = await Promise.all([
      balanceOfPromise,
      decimalsPromise,
      symbolPromise
    ]);
    const formatted = (Number(balanceOf) / 10 ** decimals).toString();
    return {
      value: balanceOf,
      decimals,
      symbol,
      formatted
    };
  };
}
var uint256Schema = z.object({
  low: z.bigint(),
  high: z.bigint()
});
var balanceSchema = z.object({
  balance: uint256Schema
});
var decimalsSchema = z.object({
  decimals: z.bigint()
});
var symbolSchema = z.object({
  symbol: z.bigint()
});
var balanceABIFragment = [
  {
    members: [
      {
        name: "low",
        offset: 0,
        type: "felt"
      },
      {
        name: "high",
        offset: 1,
        type: "felt"
      }
    ],
    name: "Uint256",
    size: 2,
    type: "struct"
  },
  {
    name: "balanceOf",
    type: "function",
    inputs: [
      {
        name: "account",
        type: "felt"
      }
    ],
    outputs: [
      {
        name: "balance",
        type: "Uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        name: "symbol",
        type: "felt"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "decimals",
        type: "felt"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/hooks/useBlock.ts
import {
  BlockTag as BlockTag2
} from "starknet";
function useBlock({
  blockIdentifier = BlockTag2.latest,
  ...props
} = {}) {
  const { provider } = useStarknet();
  return useQuery({
    queryKey: queryKey3({ blockIdentifier }),
    queryFn: queryFn3({ provider, blockIdentifier }),
    ...props
  });
}
function queryKey3({ blockIdentifier }) {
  return [{ entity: "block", blockIdentifier }];
}
function queryFn3({
  provider,
  blockIdentifier
}) {
  return async function() {
    return await provider.getBlock(blockIdentifier);
  };
}

// src/hooks/useContractFactory.ts
import { useMemo as useMemo4 } from "react";
import { ContractFactory } from "starknet";
function useContractFactory({
  compiledContract,
  classHash,
  abi
}) {
  const { account } = useAccount();
  const contractFactory = useMemo4(() => {
    if (compiledContract && account && classHash) {
      return new ContractFactory({
        compiledContract,
        classHash,
        account,
        abi
      });
    }
    return void 0;
  }, [compiledContract, classHash, account, abi]);
  return { contractFactory };
}

// src/hooks/useContractRead.ts
import { useMemo as useMemo5 } from "react";
import {
  BlockTag as BlockTag3
} from "starknet";
var DEFAULT_FETCH_INTERVAL = 5e3;
function useContractRead({
  abi,
  address,
  functionName,
  args,
  blockIdentifier = BlockTag3.latest,
  parseArgs,
  parseResult,
  refetchInterval: refetchInterval_,
  watch = false,
  enabled: enabled_ = true,
  ...props
}) {
  const { chain } = useNetwork();
  const { contract } = useContract({ abi, address });
  const queryKey_ = useMemo5(
    () => queryKey4({ chain, contract, functionName, args, blockIdentifier }),
    [chain, contract, functionName, args, blockIdentifier]
  );
  const enabled = useMemo5(
    () => Boolean(enabled_ && contract && functionName && args),
    [enabled_, contract, functionName, args]
  );
  const refetchInterval = refetchInterval_ ?? (blockIdentifier === BlockTag3.pending && watch ? DEFAULT_FETCH_INTERVAL : void 0);
  useInvalidateOnBlock({
    enabled: Boolean(enabled && watch),
    queryKey: queryKey_
  });
  return useQuery({
    queryKey: queryKey_,
    queryFn: queryFn4({
      contract,
      functionName,
      args,
      blockIdentifier,
      parseArgs,
      parseResult
    }),
    refetchInterval,
    ...props
  });
}
function queryKey4({
  chain,
  contract,
  functionName,
  args,
  blockIdentifier
}) {
  return [
    {
      entity: "readContract",
      chainId: chain?.name,
      contract: contract?.address,
      functionName,
      args,
      blockIdentifier
    }
  ];
}
function queryFn4({
  contract,
  functionName,
  args,
  blockIdentifier,
  parseArgs,
  parseResult
}) {
  return async function() {
    if (!contract)
      throw new Error("contract is required");
    if (contract.functions[functionName] === void 0) {
      throw new Error(`function ${functionName} not found in contract`);
    }
    return contract.call(functionName, args, {
      parseRequest: parseArgs,
      parseResponse: parseResult,
      blockIdentifier
    });
  };
}

// src/hooks/useContractWrite.ts
import { useCallback as useCallback5 } from "react";
function useContractWrite({
  calls,
  abis,
  options,
  ...props
}) {
  const { account } = useAccount();
  const { mutate, mutateAsync, ...result } = useMutation({
    mutationKey: mutationKey({ account, calls, abis, options }),
    mutationFn: mutationFn({ account }),
    ...props
  });
  const write = useCallback5(
    (args) => {
      return mutate({
        ...args ?? {
          calls,
          abis,
          options
        }
      });
    },
    [mutate, calls, abis, options]
  );
  const writeAsync = useCallback5(
    (args) => {
      return mutateAsync({
        ...args ?? {
          calls,
          abis,
          options
        }
      });
    },
    [mutateAsync, calls, abis, options]
  );
  return {
    write,
    writeAsync,
    ...result
  };
}
function mutationKey({
  account,
  calls,
  abis,
  options
}) {
  return [{ entity: "contractWrite", account, calls, abis, options }];
}
function mutationFn({
  account
}) {
  return async function({ calls, abis, options }) {
    if (!account)
      throw new Error("account is required");
    if (!calls || calls.length === 0)
      throw new Error("calls are required");
    return await account?.execute(calls, abis, options);
  };
}

// src/hooks/useExplorer.ts
function useExplorer() {
  const { explorer, chain } = useStarknet();
  if (!explorer)
    throw Error("Explorer is undefined. Try adding it to StarknetConfig.");
  const explorerInstance = explorer(chain);
  if (!explorerInstance)
    throw Error("Explorer Instance is undefined");
  return explorerInstance;
}

// src/hooks/useDeployAccount.ts
function useDeployAccount({
  classHash,
  constructorCalldata,
  addressSalt,
  contractAddress,
  options,
  ...props
}) {
  const { account } = useAccount();
  const { mutate, mutateAsync, ...result } = useMutation({
    mutationKey: mutationKey2({
      account,
      classHash,
      constructorCalldata,
      addressSalt,
      contractAddress,
      options
    }),
    mutationFn: mutationFn2({
      account,
      classHash,
      constructorCalldata,
      addressSalt,
      contractAddress,
      options
    }),
    ...props
  });
  return {
    deployAccount: mutate,
    deployAccountAsync: mutateAsync,
    ...result
  };
}
function mutationKey2(props) {
  return [{ entity: "deployAccount", ...props }];
}
function mutationFn2({
  account,
  classHash,
  constructorCalldata,
  addressSalt,
  contractAddress,
  options
}) {
  return async function() {
    if (!account)
      throw new Error("account is required");
    if (!classHash)
      throw new Error("classHash is required");
    return await account.deployAccount(
      { classHash, constructorCalldata, addressSalt, contractAddress },
      options
    );
  };
}

// src/hooks/useDisconnect.ts
function useDisconnect(props = {}) {
  const { disconnect, chain } = useStarknet();
  const { mutate, mutateAsync, ...result } = useMutation({
    mutationKey: [{ entity: "disconnect", chainId: chain.name }],
    mutationFn: disconnect,
    ...props
  });
  return {
    disconnect: mutate,
    disconnectAsync: mutateAsync,
    ...result
  };
}

// src/hooks/useProvider.ts
function useProvider() {
  const { provider } = useStarknet();
  return { provider };
}

// src/hooks/useSign.ts
import { useCallback as useCallback6 } from "react";
function useSignTypedData({
  domain,
  types,
  message,
  primaryType,
  ...props
}) {
  const { account } = useAccount();
  const { mutate, mutateAsync, ...result } = useMutation({
    mutationKey: mutationKey3({ domain, types, message, primaryType }),
    mutationFn: mutateFn({ account }),
    ...props
  });
  const signTypedData = useCallback6(
    (args) => mutate(
      args ?? {
        domain,
        types,
        message,
        primaryType
      }
    ),
    [mutate, domain, types, message, primaryType]
  );
  const signTypedDataAsync = useCallback6(
    (args) => mutateAsync(
      args ?? {
        domain,
        types,
        message,
        primaryType
      }
    ),
    [mutateAsync, domain, types, message, primaryType]
  );
  return {
    signTypedData,
    signTypedDataAsync,
    ...result
  };
}
function mutationKey3({
  domain,
  types,
  message,
  primaryType
}) {
  return [
    {
      entity: "signTypedData",
      domain,
      types,
      message,
      primaryType
    }
  ];
}
function mutateFn({ account }) {
  return function({
    domain,
    types,
    message,
    primaryType
  }) {
    if (!account)
      throw new Error("account is required");
    if (!domain)
      throw new Error("domain is required");
    if (!types)
      throw new Error("types is required");
    if (!message)
      throw new Error("message is required");
    if (!primaryType)
      throw new Error("primaryType is required");
    return account.signMessage({ domain, types, message, primaryType });
  };
}

// src/hooks/useStarkAddress.ts
import { useMemo as useMemo6 } from "react";
import {
  CallData as CallData2,
  Provider,
  starknetId
} from "starknet";
function useStarkAddress({
  name,
  contract,
  enabled: enabled_ = true,
  ...props
}) {
  const { provider } = useProvider();
  const { chain } = useNetwork();
  const enabled = useMemo6(() => Boolean(enabled_ && name), [enabled_, name]);
  return useQuery({
    queryKey: queryKey5({ name, contract, network: chain.network }),
    queryFn: queryFn5({ name, contract, provider, network: chain.network }),
    enabled,
    ...props
  });
}
function queryKey5({
  name,
  contract,
  network
}) {
  return [{ entity: "addressFromStarkName", name, contract, network }];
}
function queryFn5({
  name,
  contract,
  provider,
  network
}) {
  return async function() {
    if (!name)
      throw new Error("name is required");
    const namingContract = contract ?? StarknetIdNamingContract[network];
    const p = new Provider(provider);
    const encodedDomain = decodeDomain(name);
    const calldata = network === "mainnet" ? { domain: encodedDomain } : { domain: encodedDomain, hint: [] };
    const result = await p.callContract({
      contractAddress: namingContract,
      entrypoint: "domain_to_address",
      calldata: CallData2.compile(calldata)
    });
    if (BigInt(result.result[0]) === BigInt(0))
      throw new Error("Address not found");
    return result.result[0];
  };
}
var StarknetIdNamingContract = {
  goerli: "0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce",
  sepolia: "0x5847d20f9757de24395a7b3b47303684003753858737bf288716855dfb0aaf2",
  mainnet: "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678"
};
var decodeDomain = (domain) => {
  if (!domain)
    return ["0"];
  const encoded = [];
  for (const subdomain of domain.replace(".stark", "").split("."))
    encoded.push(starknetId.useEncoded(subdomain).toString(10));
  return encoded;
};

// src/hooks/useStarkName.ts
import { useMemo as useMemo7 } from "react";
import { Provider as Provider2 } from "starknet";
function useStarkName({
  address,
  contract,
  enabled: enabled_ = true,
  ...props
}) {
  const { provider } = useProvider();
  const { chain } = useNetwork();
  contract = chain.network === "sepolia" ? "0x5847d20f9757de24395a7b3b47303684003753858737bf288716855dfb0aaf2" : contract;
  const enabled = useMemo7(
    () => Boolean(enabled_ && address),
    [enabled_, address]
  );
  return useQuery({
    queryKey: queryKey6({ address, contract }),
    queryFn: queryFn6({ address, contract, provider }),
    enabled,
    ...props
  });
}
function queryKey6({
  address,
  contract
}) {
  return [{ entity: "starkName", address, contract }];
}
function queryFn6({
  address,
  contract,
  provider
}) {
  return async function() {
    if (!address)
      throw new Error("address is required");
    const p = new Provider2(provider);
    return await p.getStarkName(address, contract);
  };
}

// src/hooks/useWaitForTransaction.ts
import { useMemo as useMemo8 } from "react";
function useWaitForTransaction({
  hash: hash2,
  watch,
  enabled: enabled_ = true,
  ...props
}) {
  const { provider, chain } = useStarknet();
  const queryKey_ = useMemo8(() => queryKey7({ chain, hash: hash2 }), [chain, hash2]);
  const enabled = useMemo8(() => Boolean(enabled_ && hash2), [enabled_, hash2]);
  useInvalidateOnBlock({
    enabled: Boolean(enabled && watch),
    queryKey: queryKey_
  });
  return useQuery({
    queryKey: queryKey_,
    queryFn: queryFn7({ provider, hash: hash2 }),
    enabled,
    ...props
  });
}
function queryKey7({ chain, hash: hash2 }) {
  return [
    { entity: "transactionReceipt", chainId: chain?.name, hash: hash2 }
  ];
}
function queryFn7({
  provider,
  hash: hash2
}) {
  return async function() {
    if (!hash2)
      throw new Error("hash is required");
    return await provider.getTransactionReceipt(hash2);
  };
}

// src/hooks/useStarkProfile.ts
import { useMemo as useMemo9 } from "react";
import {
  CairoCustomEnum,
  Provider as Provider3,
  cairo,
  hash,
  shortString as shortString2
} from "starknet";
function useStarkProfile({
  address,
  useDefaultPfp = true,
  namingContract,
  identityContract,
  enabled: enabled_ = true,
  ...props
}) {
  const { provider } = useProvider();
  const { chain } = useNetwork();
  const { contract: multicallContract } = useContract({
    abi: multicallABI,
    address: StarknetIdcontracts[chain.network]["multicall"]
  });
  const enabled = useMemo9(
    () => Boolean(enabled_ && address),
    [enabled_, address]
  );
  return useQuery({
    queryKey: queryKey8({ address, namingContract, identityContract }),
    queryFn: queryFn8({
      address,
      useDefaultPfp,
      namingContract,
      provider,
      network: chain.network,
      identityContract,
      multicallContract
    }),
    enabled,
    ...props
  });
}
function queryKey8({
  address,
  namingContract,
  identityContract
}) {
  return [
    { entity: "starkprofile", address, namingContract, identityContract }
  ];
}
function queryFn8({
  address,
  useDefaultPfp,
  namingContract,
  identityContract,
  provider,
  network,
  multicallContract
}) {
  return async function() {
    if (!address)
      throw new Error("address is required");
    if (!multicallContract)
      throw new Error("multicallContract is required");
    if (!network)
      throw new Error("network is required");
    const contracts = StarknetIdcontracts[network];
    const identity = identityContract ?? contracts["identity"];
    const naming = namingContract ?? contracts["naming"];
    const p = new Provider3(provider);
    const name = await p.getStarkName(address, naming);
    const data = await multicallContract.call("aggregate", [
      [
        {
          execution: staticExecution(),
          to: hardcoded(naming),
          selector: hardcoded(hash.getSelectorFromName("address_to_domain")),
          calldata: [hardcoded(address)]
        },
        {
          execution: staticExecution(),
          to: hardcoded(naming),
          selector: network === "mainnet" ? hardcoded(hash.getSelectorFromName("domain_to_token_id")) : hardcoded(hash.getSelectorFromName("domain_to_id")),
          calldata: [arrayReference(0, 0)]
        },
        {
          execution: staticExecution(),
          to: hardcoded(identity),
          selector: hardcoded(hash.getSelectorFromName("get_verifier_data")),
          calldata: [
            reference(1, 0),
            hardcoded(shortString2.encodeShortString("twitter")),
            hardcoded(contracts["verifier"]),
            hardcoded("0")
          ]
        },
        {
          execution: staticExecution(),
          to: hardcoded(identity),
          selector: hardcoded(hash.getSelectorFromName("get_verifier_data")),
          calldata: [
            reference(1, 0),
            hardcoded(shortString2.encodeShortString("github")),
            hardcoded(contracts["verifier"]),
            hardcoded("0")
          ]
        },
        {
          execution: staticExecution(),
          to: hardcoded(identity),
          selector: hardcoded(hash.getSelectorFromName("get_verifier_data")),
          calldata: [
            reference(1, 0),
            hardcoded(shortString2.encodeShortString("discord")),
            hardcoded(contracts["verifier"]),
            hardcoded("0")
          ]
        },
        {
          execution: staticExecution(),
          to: hardcoded(identity),
          selector: hardcoded(hash.getSelectorFromName("get_verifier_data")),
          calldata: [
            reference(1, 0),
            hardcoded(shortString2.encodeShortString("proof_of_personhood")),
            hardcoded(contracts["verifier_pop"]),
            hardcoded("0")
          ]
        },
        // PFP
        {
          execution: staticExecution(),
          to: hardcoded(identity),
          selector: hardcoded(hash.getSelectorFromName("get_verifier_data")),
          calldata: [
            reference(1, 0),
            hardcoded(shortString2.encodeShortString("nft_pp_contract")),
            hardcoded(contracts["verifier_pfp"]),
            hardcoded("0")
          ]
        },
        {
          execution: staticExecution(),
          to: hardcoded(identity),
          selector: hardcoded(
            hash.getSelectorFromName("get_extended_verifier_data")
          ),
          calldata: [
            reference(1, 0),
            hardcoded(shortString2.encodeShortString("nft_pp_id")),
            hardcoded("2"),
            hardcoded(contracts["verifier_pfp"]),
            hardcoded("0")
          ]
        },
        {
          execution: notEqual(6, 0, 0),
          to: reference(6, 0),
          selector: hardcoded(hash.getSelectorFromName("tokenURI")),
          calldata: [reference(7, 1), reference(7, 2)]
        }
      ]
    ]);
    if (Array.isArray(data)) {
      const twitter = data[2][0] !== BigInt(0) ? data[2][0].toString() : void 0;
      const github = data[3][0] !== BigInt(0) ? data[3][0].toString() : void 0;
      const discord = data[4][0] !== BigInt(0) ? data[4][0].toString() : void 0;
      const proofOfPersonhood = data[5][0] === BigInt(1) ? true : false;
      const profile = data.length === 9 ? data[8].slice(1).map(
        (val) => shortString2.decodeShortString(val.toString())
      ).join("") : void 0;
      const profilePicture = profile ? await fetchImageUrl(profile) : useDefaultPfp ? `https://starknet.id/api/identicons/${data[1][0].toString()}` : void 0;
      return {
        name,
        twitter,
        github,
        discord,
        proofOfPersonhood,
        profilePicture,
        profile
      };
    } else {
      throw new Error("Error while fetching data");
    }
  };
}
var hardcoded = (arg) => {
  return new CairoCustomEnum({
    Hardcoded: arg
  });
};
var reference = (call, pos) => {
  return new CairoCustomEnum({
    Reference: cairo.tuple(call, pos)
  });
};
var arrayReference = (call, pos) => {
  return new CairoCustomEnum({
    ArrayReference: cairo.tuple(call, pos)
  });
};
var staticExecution = () => {
  return new CairoCustomEnum({
    Static: {}
  });
};
var notEqual = (call, pos, value) => {
  return new CairoCustomEnum({
    IfNotEqual: cairo.tuple(call, pos, value)
  });
};
var fetchImageUrl = async (url) => {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error("Network response was not ok");
    }
    const data = await response.json();
    if (data.image) {
      return data.image;
    } else {
      return "Image is not set";
    }
  } catch (error) {
    console.error("There was a problem fetching the image URL:", error);
    return "Error fetching data";
  }
};
var StarknetIdcontracts = {
  goerli: {
    naming: "0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce",
    identity: "0x783a9097b26eae0586373b2ce0ed3529ddc44069d1e0fbc4f66d42b69d6850d",
    verifier: "0x019e5204152a72891bf8cd0bed8f03593fdb29ceacd14fca587be5d9fcf87c0e",
    verifier_pop: "0x03528caf090179e337931ee669a5b0214041e1bae30d460ff07d2cea2c7a9106",
    verifier_pfp: "0x03cac3228b434259734ee0e4ff445f642206ea11adace7e4f45edd2596748698",
    multicall: "0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970"
  },
  sepolia: {
    naming: "0x5847d20f9757de24395a7b3b47303684003753858737bf288716855dfb0aaf2",
    identity: "0x718d9172f6e36183abeeff1a0db76a1851cef4ed9b9c13896da79ef4bfcb4d0",
    verifier: "0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf",
    verifier_pop: "0x00f80f68443becd0e0a4a08ff5734e36dd8028507333e4a0ec034dcfdf1b793e",
    verifier_pfp: "0x070c035557d6fed57eed2ed7fa861616b487f8a95439347b805639ca076f29f0",
    multicall: "0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970"
  },
  mainnet: {
    naming: "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678",
    identity: "0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af",
    verifier: "0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf",
    verifier_pop: "0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4",
    verifier_pfp: "0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7",
    multicall: "0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970"
  }
};
var multicallABI = [
  {
    type: "impl",
    name: "ComposableMulticallImpl",
    interface_name: "composable_multicall::IComposableMulticall"
  },
  {
    type: "enum",
    name: "composable_multicall::Execution",
    variants: [
      { name: "Static", type: "()" },
      {
        name: "IfEqual",
        type: "(core::integer::u32, core::integer::u32, core::felt252)"
      },
      {
        name: "IfNotEqual",
        type: "(core::integer::u32, core::integer::u32, core::felt252)"
      }
    ]
  },
  {
    type: "enum",
    name: "composable_multicall::DynamicFelt",
    variants: [
      { name: "Hardcoded", type: "core::felt252" },
      { name: "Reference", type: "(core::integer::u32, core::integer::u32)" }
    ]
  },
  {
    type: "enum",
    name: "composable_multicall::DynamicCalldata",
    variants: [
      { name: "Hardcoded", type: "core::felt252" },
      { name: "Reference", type: "(core::integer::u32, core::integer::u32)" },
      {
        name: "ArrayReference",
        type: "(core::integer::u32, core::integer::u32)"
      }
    ]
  },
  {
    type: "struct",
    name: "composable_multicall::DynamicCall",
    members: [
      { name: "execution", type: "composable_multicall::Execution" },
      { name: "to", type: "composable_multicall::DynamicFelt" },
      { name: "selector", type: "composable_multicall::DynamicFelt" },
      {
        name: "calldata",
        type: "core::array::Array::<composable_multicall::DynamicCalldata>"
      }
    ]
  },
  {
    type: "struct",
    name: "core::array::Span::<core::felt252>",
    members: [
      { name: "snapshot", type: "@core::array::Array::<core::felt252>" }
    ]
  },
  {
    type: "interface",
    name: "composable_multicall::IComposableMulticall",
    items: [
      {
        type: "function",
        name: "aggregate",
        inputs: [
          {
            name: "calls",
            type: "core::array::Array::<composable_multicall::DynamicCall>"
          }
        ],
        outputs: [
          { type: "core::array::Array::<core::array::Span::<core::felt252>>" }
        ],
        state_mutability: "view"
      }
    ]
  },
  {
    type: "event",
    name: "composable_multicall::contract::ComposableMulticall::Event",
    kind: "enum",
    variants: []
  }
];
export {
  Connector,
  ConnectorAlreadyConnectedError,
  ConnectorNotConnectedError,
  ConnectorNotFoundError,
  InjectedConnector,
  MockConnector,
  AccountProvider as OverrideAccount,
  StarkCompassExplorer,
  StarknetConfig,
  StarkscanExplorer,
  UnsupportedAccountInterfaceError,
  UserNotConnectedError,
  UserRejectedRequestError,
  ViewblockExplorer,
  VoyagerExplorer,
  alchemyProvider,
  argent,
  blastProvider,
  braavos,
  infuraProvider,
  injected,
  jsonRpcProvider,
  lavaProvider,
  nethermindProvider,
  publicProvider,
  reddioProvider,
  starkcompass,
  starknetChainId,
  starkscan,
  useAccount,
  useBalance,
  useBlock,
  useBlockNumber,
  useConnect,
  useContract,
  useContractFactory,
  useContractRead,
  useContractWrite,
  useDeployAccount,
  useDisconnect,
  useExplorer,
  useInjectedConnectors,
  useInvalidateOnBlock,
  useNetwork,
  useProvider,
  useSignTypedData,
  useStarkAddress,
  useStarkName,
  useStarkProfile,
  useWaitForTransaction,
  viewblock,
  voyager
};
//# sourceMappingURL=index.js.map